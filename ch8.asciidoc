:library: Asciidoctor
:toc:
:toc-placement!:


= Grow with Google Challenge Notes: Chapter 8 aka Lesson 3

Built-Ins notes +
To go back to the README where all the chapters are: click link:README.asciidoc[here].


toc::[]

== 8.1 : New Built-Ins 

These are the new Built-Ins that were put in with ES6

* Sets
* Maps 
* Promises
* and more...

These built-ins will make it much easier to execute tasks that were more difficult before. In this lesson we are going to:

* See how the new built-ins are structured
* See how the new built-ins work.
* and when to use these new built-ins.

== 8.2 : Symbols Intro

Symbols is a new addition to the primitive data type in JavaScript.

Here are the current primitive data types:
====

* numbers 
* String 
* booleans
* null
* undefined
* symbols
====

So what is Symbol?

Symbol is a unique idenitfier, most used to uniquely identify properties within an object.

Example:
Bowl has 2 bananas, 1 orange, and 1 apple.

Symbol will help identify each of those bananas as banana1 and banana2, but it'll be easier. We'll see!

== 8.3 : Symbols



To create a symbol, we write *Symbol()* with an optional string as its description.

----
const sym1 = Symbol('apple');
----

Adding a description *'apple'* is just a way to describe the symbol, but it can't be used to access the symbol itself.

To show how it works, we'll compare the two symbols with the same description.

----
const sym2 = Symbol('banana');
const sym3 = Symbol('banana');
console.log(sym2 === sym3);
----

The result will be *false* because the description has no effect on the symbol itself but for description only.

''''

Here's to show how a symbol can be useful.

----
const bowl = {
  'apple': { color: 'red', weight: 136.078 },
  'banana': { color: 'yellow', weight: 183.151 },
  'orange': { color: 'orange', weight: 170.097 },
  'banana': { color: 'yellow', weight: 176.845 }
};

console.log(bowl);
----

When we run this, the second banana will overwrite the first banana.

This is the output for *console.log(bowl)*:
====
----
{ apple: { color: 'red', weight: 136.078 },
  banana: { color: 'yellow', weight: 176.845 },
  orange: { color: 'orange', weight: 170.097 } }
----
====

''''
To fix this problem, we have to use Symbols.

Here is how we'd write it:
----
const bowl = {
  [Symbol('apple')]: { color: 'red', weight: 136.078 },
  [Symbol('banana')]: { color: 'yellow', weight: 183.15 },
  [Symbol('orange')]: { color: 'orange', weight: 170.097 },
  [Symbol('banana')]: { color: 'yellow', weight: 176.845 }
};
console.log(bowl);
----

will print out: 
====
----
{ [Symbol(apple)]: { color: 'red', weight: 136.078 },
  [Symbol(banana)]: { color: 'yellow', weight: 183.15 },
  [Symbol(orange)]: { color: 'orange', weight: 170.097 },
  [Symbol(banana)]: { color: 'yellow', weight: 176.845 } }
----
====

because when the properties use symbols, each property is a unique Symbol and the first banana doesn't get overwritten by the second banana anymore.


== 8.4 : Iteration & Iterable Protocols

Before we continue on, the instructors want us to understand these new protocols in ES6. 

* the *iterable* protocol
* the *iterator* protocol

=== The Iterable Protocol 

Let's start with Iterable.

What the iterable protocol does is define and customize the iteration behavior of objects. +
Which means we now have the flexibility in ES6 to specify a way for iterating through values in an object.

Before, strings and arrays had built-in iterables. +

Code refresher: Array built-in iterable
----
const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for (const digit of digits) {
  console.log(digit);
}
----

will print:
----
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
----

Later in this lesson, they'll cover more on that and also more built-in iterables like *Sets* and *Maps*.

''''
When we were learning *for...of* loops, they said that objects can be iterated _only_ if they're *iterable*. +
To make an object iterable, we have to implement the *iterable interface*. +
The *iterable interface* means it must contain a *default iterator method*. This method will define how the object should be iterated.

So now we have to understand what the *iterator method* is...

=== The Iterator Protocol 

The iterator method is available through constant: *[Symbol.iterator]* is a zero arguments function 
that returns an iterator object. +
An iterator object is an object that follows the rules of the iterator protocol.

The iterator protocol has a process for defining how an object will iterate. This is done through using the *.next()* method.

The object becomes an iterator when it implements the *.next()* method. The *.next()* method is a zero arguments function that returns an object with [underline]#two properties#.

The two properties: 

. *value* : the data representing the value that was used for the *.next()* method.
. *done* : a [underline]#boolean# representing if the iterator is _done_ going through the sequence of values.
  * If done is *true*, then the iterator has reached the end of its sequence of values.
  * If done is *false*, then the iterator is able to produce another value in its sequence of values.

Here is how to write an iterator using an array. I made it shorter than the example that way we can see done as *true* and *false*

----
const digits = ['can1', 'can2', 'can3'];
const arrayIterator = digits[Symbol.iterator]();

console.log(arrayIterator.next());
console.log(arrayIterator.next());
console.log(arrayIterator.next());
console.log(arrayIterator.next());
----

This will print out: 

====
----
{ value: 0, done: false }
{ value: 1, done: false }
{ value: 2, done: false }
{ value: undefined, done: true }
----
====


== 8.5 : Sets

A set in mathematics is something like this: {2, 4, 5, 6} +
because each of the numbers in the collection are unique. + 

However...
{1, 1, 2, 3} is not a set because it contains *duplicate* entries. [underline]#1# appears more than once.

JavaScript on the other hand, doesn't care and will let you have duplicated entries.
However, doing so will break the [underline]#mathematical# set rule.

Now if you want JavaScript to follow the mathematical set rule, you need to use *new Set()*. +
Sets lets you add or remove items, and loop, but each of the items have to be unique.

''''

Here's how to create a set: 
----
const games = new Set();
console.log(games);
----

will print out an empty Set games with no items.
====
set {}
====

''''

If you want to create a Set from a list of values, you can use an array:

----
const games = new Set(['Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart', 'Super Mario Bros.']);
console.log(games);
----

prints out: 
====
----
Set { 'Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart' }
----
====

In this example, the duplicate object was automatically removed. In this case, it removed "*Super Mario Bros"*.


=== Sets quiz 

This quiz wants to check if you've been paying attention.

Reminder: Sets is a collection of values that has to be unique.

====
Option 1: {1, 'Basketball', true, false, '1'}

Option 2: {}

Option 3: {1, 1, 1, 1}

Option 4: {false, '0', 0, 'Soccer', 3.14, 25, 0}

Option 5: {'Gymnastics', 'Swimming', 2}
====

Answer:  They put in different data types to try and trick you. So a number 1 and a string 1 are considered unique from each other. So the answers are Options 1, 2, and 5.

== 8.6 : Modifying Sets

now that we know how to create sets, now we can learn how to use them.

Using this set:
----
const games = new Set(['Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart', 'Super Mario Bros.']);
----

Here's how to *add* to the set:

----
games.add('Banjo-Tooie');
----

If we print it out with console.log(games); we would get: 
----
Set {
  'Super Mario Bros.',
  'Banjo-Kazooie',
  'Mario Kart',
  'Banjo-Tooie' }
----
with our new *Banjo-Tootie* at the very bottom.



''''
If we wanted to *delete*, we type in:

----
games.delete('Super Mario Bros.');
----

our new result would be:
----
Set { 'Banjo-Kazooie', 'Mario Kart', 'Banjo-Tooie' }
----



''''

If we want to delete all of the items from the Set, we can simply use the *.clear()* method.

----
games.clear()
----

prints the familiar empty Set.
----
Set {}
----
''''
[NOTE]
====
* If you try to *.add()* an item that is already in the set, you will not receive an error, instead the item will just be ignored. +
    . The .add() will return the *Set* if an item was successfully added.
* If you try to *.delete()* an item that is not in the set, you will not receive an error, instead the command will just be ignored.
    . The .delete() returns a Boolean depending on successful deletion.
====

== 8.7 : Working with Sets
There are a number of different properties and methods we can use to work with sets.

=== Checking the Length

Now that we've made a Set, we want to see how many items are in it. +
here, we use: *.size* property.

Here's how to use it 
----
const months = new Set(['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']);
console.log(months.size);
----
This will print out: *12*.

NOTE: Sets can't be accessed by their index like an array, so you use the .size property instead of .length property to get the size of the Set.

=== Check if an Item Exists.

To check if an item exists in the Set, we use *.has()* method.

* If the item is in the set, then .has() will return *true*.
* If the item is NOT in the set, then .has() will return *false*.

To use:
----
console.log(months.has('September'));
----

will print: *true*

=== Retrieving all Values

If we want to return all the values in a Set, we use the *.values()* method. The returned values from *.values()* method is a *SetIterator* object.

Here's how to use:
----
console.log(months.values());
----

You get a *SetIterator* with a lists of the months in {}. 

NOTE: SetIterator is shown empty on sites like JSBin and Repl.it. however, if you use it in devtools, you can really see the details and what's inside.
Here's a screen shot of using just *months* vs *months.values()* +
image:img/sets1.png[] +

''''

Another note is that .keys() method behaves the same way as .values() method by returning the values of a Set within a new iterator Object.
The .keys() method is an alias for the .values() method for similarity with maps. We will get more into .keys() when when we cover maps.

== 8.8 : Sets & Iterators

Because the *.values()* method returns a new iterator object called *SetIterator*, you can store that iterator object in a variable and loop through each item in the Set using .next().

----
const iterator = months.values();
iterator.next();
----

will print: *Object {value: 'January', done: false}* +
If you type *iterator.next()* again, you will get *{'February', done: false}*. This will keep going until *done: true*.

''''

There's an easier way to loop through the items in a Set, and that is to use the *for...of loop*.

----
const colors = new Set(['red', 'orange', 'yellow', 'green', 'blue', 'violet', 'brown', 'black']);
for (const color of colors) {
  console.log(color);
}
----

Which will print: 
----
red
orange
yellow
green
blue
violet
brown
black
----
== 8.9 : Quiz: Using Sets

=== Refresher for the quiz
This was a long subject so maybe a refresher is needed.

Code Refresher: 
====
*Here's how to create a set:*
----
const name = new Set();
----
====

====
*Here's how to add an item into the set*

----
name.add('item1')
----
====

====
*Here's how to delete an item from the set*

----
name.delete('item2')
----
====

''''
=== Using Sets Quiz 

* They want you to create a set with the name: *myFavoriteFlavors*

* They want you to add in these strings: 
    . "chocolate chip"
    . "cookies and cream"
    . "strawberry"
    . "vanilla"
* They want you to delete this item from the set:
    . "strawberry"

''''

Answer 
====
----
const myFavoriteFlavors = new Set();

myFavoriteFlavors.add('chocolate chip');
myFavoriteFlavors.add('cookies and cream');
myFavoriteFlavors.add('strawberry');
myFavoriteFlavors.add('vanilla');
myFavoriteFlavors.delete('strawberry')

console.log(myFavoriteFlavors)
----
====


== 8.10 : WeakSets

WeakSet is like a normal Set but it's different in these ways:

* WeakSet can only contain *objects*.
* WeakSet is *not iterable* which means it cannot be looped over.
* WeakSet does not have a *.clear()* method.


To create a Weakset, you do the same thing as a normal Set.

----
const roster = new WeakSet();
----

However, like what was mentioned earlier, it only accepts objects.

Objects:
----
const student1 = { name: 'James', age: 26, gender: 'male' };
const student2 = { name: 'Julia', age: 27, gender: 'female' };
const student3 = { name: 'Richard', age: 31, gender: 'male' };
----

New Weaksets:
----
const roster = new WeakSet([student1, student2, student3]);
console.log(roster);
----

If you try to add a string inside the weakset like this:

----
roster.add('Amanda');
----

You get the error:

----
Uncaught TypeError: Invalid value used in weak set(…)
----

=== WeakSet's purpose

If Sets can have many datatypes and WeakSets can only have Objects, then why do we need WeakSets?

The reason is because of the *.clear()* method.

=== Garbage Collection

In JavaScript, memory is allocated when new values are created and is "automatically" freed up when
those values are no longer needed. This process of freeing up memory after it is no longer needed is what is known 
as *garbage collection*.

WeakSets take advantage of this by exclusively working with objects. If you set an object to *null*, then
you're essentially deleting the object. And when JavaScript's *garbage collector* runs, the
memory that object previously occupied will be freed up to be used later in your program.


For example:

====
----
student3 = null 
console.log(roster);
----

Will print out: +
*WeakSet {Object {name: 'Julia', age: 27, gender: 'female'}, Object {name: 'James', age: 26, gender: 'male'}}*

====

What makes WeakSet suseful is that you don't have to worry about deleting references to deleted objects in your
weakSets, because JavaScript does it for us. When an object is deleted, the object will also 
be deleted from the WeakSet when garbage collection runs. *This makes WeakSet useful in 
situations where you want an efficient, lightweight solution for creating groups of objects*.


== 8.11 : Quiz: Working With WeakSets 

Quiz Time!
=== Refresher
Just in case you need a refresher!

====
*To add a WeakSet*
----
const name = new WeakSet()
----
====

====
*to add an object into a WeakSet*
----
One Object: 

name.add(object1);

More than one Object: 

name.add([object1, object2, object3])

----
====

=== Quiz: Working With WeakSets 

NOTE: Keep in mind that they want you to add the objects one by one. So there should be 3 .add().

* Create a WeakSet with the name *uniqueFlavors*
* create an object with the name *flavor1* with the properties: *{flavor: 'chocolate'}*
* create an object with the name *flavor2* with the properties: *{flavor:}* Give the value of flavor whatever you want.
* use the *.add()* method to add the objects *flavor1* and *flavor2* to *uniqueFlavors*.
* use the *.add()* method to add *flavor1* to *uniqueFlavors* WeakSet, again.

Answer
====
----
const uniqueFlavors = new WeakSet();

const flavor1 = {flavor: 'chocolate'};
const flavor2 = {flavor: 'chocolate chip'};


uniqueFlavors.add(flavor1);
uniqueFlavors.add(flavor2);
uniqueFlavors.add(flavor1);

console.log(uniqueFlavors)
----
====

== 8.12 : Maps

Introducing Maps and WeakMaps. 

Maps and WeakMaps are actually similar. 

====
Here is what they have in common:

* They have similar properties. 
* Maps and Sets are both iterable. Which means we can loop over them.
* WeakMaps and WeakSets don't prevent garbage collection.
====

====
Here is what Maps and WeakMaps has that's different.

* Maps are collections of key-value pairs while Sets are collections of unique values.

example:
----
Maps 

        {
            key1: value1
            richard: 'is awesome'
            james: 'wants to be cool like richard'
        }

Sets are collections of unique values

        [val1, val2, val3]
----
A nice way to see them is *Sets::Arrays* and *Maps::Objects*
====



== 8.13 : Creating & Modifying Maps

Essentially, a Map is an object that lets you store key-value pairs when both the keys and the values can be
objects, primitive values, or a combination of the two.

=== Here's how to create a Map 

To create a Map, type:

----
const employees = new Map();
----

If we console.log this, it would print out: *Map {}* Employee will be created with no key-value pairs.

=== Modifying Maps 

==== Adding to a Map

====


Unlike Sets, you can't create Maps from a list of values; instead, you add key-values
by using the Map's *.set()* method.

----
const employees = new Map();

employees.set('james.parkes@udacity.com', { 
    firstName: 'James',
    lastName: 'Parkes',
    role: 'Content Developer' 
});
employees.set('julia@udacity.com', {
    firstName: 'Julia',
    lastName: 'Van Cleve',
    role: 'Content Developer'
});
employees.set('richard@udacity.com', {
    firstName: 'Richard',
    lastName: 'Kalehoff',
    role: 'Content Developer'
});

console.log(employees);
----

It will print out: +
image:img/map1.png[] +
The *.set()* method takes two arguments. The first argument is the [underline]#key#, which is used to reference the second argument, which is [underline]#value#.

NOTE: When you use the *.set()* on a key-value pair to a Map that already uses the same key, you
won't receive an error, but the key-value pair will overwrite what currently exists in the Map. +
The return value of *.set()* is the Map object itself if the operation was successful.

====

==== Deleting from a map. 

====
If you want to remove [underline]#key-value# pair(s), simply use the *.delete()* method.

----
employees.delete('julia@udacity.com');
employees.delete('richard@udacity.com');
----

now it will only print out:

----
Map {
  'james.parkes@udacity.com' => { firstName: 'James',
  lastName: 'Parkes',
  role: 'Content Developer' } }
----

NOTE: If you try to *.delete()* a key-value pair that is not in a Map, you won't receive an error, and the
Map will remain unchanged. +
Just like in [underline]#Sets#, .delete() method returns true if a key value pair is succesfully deleted
from the Map object, and false if unsuccessful.
====

=== Remove all 

====
Similar to Sets, you can use the *.clear()* method to remove all key-value pairs from the Map.

----
employees.clear()
----

will print out an empty Map:

----
Map {}
----
====


== 8.14 : Working with Maps

=== Checking your Map 
====
To check to see if a [underline]#key-value# pair exists inside the Map, use *.has()*.

----
const members = new Map();

members.set('Evelyn', 75.68);
members.set('Liam', 20.16);
members.set('Sophia', 0);
members.set('Marcus', 10.25);

console.log(members.has('Xavier'));
console.log(members.has('Marcus'));
----

You would get the results:

* *false* for [underline]#Xavier#
* *true* for [underline]#Marcus#
====

=== Retrieving values 

====
If you need to retrieve a Value from a Map, you need to pass in its *key* using the *get()* method.

----
console.log(members.get('Evelyn'));
----

Should get this result:

----
75.68
----
====


== 8.15 : Looping Through Maps

We have 3 different ways to loop through Maps.

* Step through each key or value using the *Map's default iterator*
* Loop through each key-value pair using the new *for...of* loop 
* Loop through each key-value pair using the Map's *.forEach()* method.

Let's check them out one by one.

=== MapIterator

Using both the *.keys()* and *.values()* methods on a Map will return a new iterator object
called *MapIterator*. +
You can store that iterator object in a new variable and use *.next()* to 
loop through each key or value. +
Depending on which method you use, it will determine if your iterator 
has access to the Map's keys or the Map's values.

----
let iteratorObjForKeys = members.keys();
iteratorObjForKeys.next();
----

will return 
----
Object {value: 'Evelyn', done: false}
----

You can keep using *.next()* until [underline]#done# is *true*

----
let iteratorObjForKeys = members.keys();
iteratorObjForKeys.next();
{value: "Evelyn", done: false}
iteratorObjForKeys.next();
{value: "Liam", done: false}
iteratorObjForKeys.next();
{value: "Sophia", done: false}
iteratorObjForKeys.next();
{value: "Marcus", done: false}
iteratorObjForKeys.next();
{value: undefined, done: true}
----

=== Using for...of Loop

This is the familiar *for...of* loop to be used with *Maps*.

----
for (const member of members) {
  console.log(member);
}
----

will print out: 
+
image:img/map2.png[] +

Though, when using *for...of* loop with a Map, you don't exactly get back a *key* or a *value*.
Instead, the key-value pair is split up into an array where the first element is the *key* and 
the second element is the value.  

What you need to do is use the *array deconstructuring inside the for...of loop*.

=== Quiz: 

====

Code Refresher:


Array Destructuring 
----
var x = [1, 2, 3, 4, 5];
var [y, z] = x;
----
====

====
Using array destructuring to fix the following code to print the keys and values of the 'members' Map
to the console.
----
for (const member of members) {
    console.log(member)
}
----
====

Answer 
====
----
for (const [key, value] of members) {
    console.log(key, value)
}

----

which will print out + 
image:img/map3.png[]
====

Did you know that *for...of* loops support destructuring? I didn't. Here's a tiny bit of information
on it (and I really mean *tiny*): link:http://2ality.com/2015/01/es6-destructuring.html#examples-of-destructuring[destructuring with for...of loop]

----
for (const [key, value] of members) {
    console.log(`${key} has ${value}`)
}
----

=== Using the forEach Loop
Just when I learned about deconstructing for...of loops, turns out there's an easier method.

Introducing the *forEach* loop. 

Here's how to use it: 

----
members.forEach((key, value) => console.log(key, value));
----

will print out: 

image:img/map4.png[]

Okay, something funky is going on here.... I'll check back later on this.... +
AND I'm back. Apparently, values show first when it comes to iterating maps.

[NOTE]
====
When we wrote in *.forEach(key, value)*  [underline]#key, value# wasn't a deconstructoring thing, it was just an argument for the map in this order:

. the element value
. the element key
. the Map object being traversed

So if we wanted the argument to be accurate, it should have been written like this: +
 *.forEach(value, key)*

More on that here: link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach[MDN]
====

Okay, I think we can move on now!

== 8.16 : WeakMaps

A WeakMap is just like a normal Map with a few differences such as:

* a WeakMap can only contain objects as keys
* a WeakMap is *not* iterable which means it can't be looped and 
* a WeakMap does not have a .clear() method.

=== Creating WeakMaps 

You create it the same as you would Set, WeakSet, and Map. 

----
const library = new WeakMap()
----

You also add in the same way as *Map* by using *.set()*. 

----
const book1 = { title: 'Pride and Prejudice', author: 'Jane Austen' };
const book2 = { title: 'The Catcher in the Rye', author: 'J.D. Salinger' };
const book3 = { title: 'Gulliver’s Travels', author: 'Jonathan Swift' };
----

Test it out with this: 

----
library.set(book1, true);
library.set(book2, false);
library.set(book3, true);

console.log(library);
----

Should get this result: +
image:img/map5.png[]

''''
However, if you try to add something other than an *object* as key, you'll get an error.

----
library.set('The Grapes of Wrath', false);
----

You will get this error: +
image:img/map6.png[] +

We get this error because *WeakMap* can only contain objects as keys. Again, similar to 
WeakSets, weakMaps leverage garbage collection for easier use and maintainability. 


NOTE: WeakMap's Garbage collection is very identical to *WeakSet's Garbage Collection*. If you need a refresher,
scroll up: link:ch8.asciidoc#garbage-collection[garbage collection].

== 8.17 : Promises Intro

James and Richard show a real life scenario of what *Promises* are.

JavaScript is a new way of handling *asynchronous* requests.


*In Summary:* +
Making a request for something and the downtime waiting for that request to be fulfilled and being able to do
other work while we wait and then later be notified when the request is finished is what *promises* does for us in 
JavaScript.

== 8.18 : Promises

=== Creating Promises 

Promises are created with the Promise constructor function *new Promise()*. A promise
will let you start some work that will be done *asynchronously* and let you get back to 
your regular work. When you create the promise, you must give it the code that will be 
run asynchronously. You provide this code as the argument of the constructor function: 


----
new Promise(function () {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
        const sundae = {};
        // request ice cream
        // get cone
        // warm up ice cream scoop
        // scoop generous portion into cone!
    }, Math.random() * 2000);
});
----

This code creates a promise that will start in a few seconds after I make a request. Then there are 
a number of steps that need to be made in the *createSundae* function. The way I see it, it's 
similar to when James was waiting for Richard to place an order. 

=== Indicated a successful request or a Failed Request 

But once that's all done, we need a way for JavaScript to tell us that the request is complete.
That is when we use *resolve*. Resolve is used to indicate that this function should be 
called when the request completes successfully. Here we added *resolve* after all the requests.

----
new Promise(function (resolve, reject) {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
        const sundae = {};
        // request ice cream
        // get cone
        // warm up ice cream scoop
        // scoop generous portion into cone!
        resolve(sundae);
    }, Math.random() * 2000);
});
----

Once the sundae is successfully created, it calls the *resolve* method and passed the data 
we want to return. Such as this completed sundae. The *resolve* method is used to indicate that the request 
is complete and that it completed _successfully_.

''''

If there is a problem with the request and it couldn't be completed, then we could use the second 
function that's passed to the function. Typically, this function is stored in an identifier called 
*"reject"* to indicate that this function should be used if the request fails for some reason. This code we added 
*reject*.

----
new Promise(function (resolve, reject) {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
        const sundae = {};
        // request ice cream
        // get cone
        // warm up ice cream scoop
        // scoop generous portion into cone!
        if ( /* iceCreamConeIsEmpty(flavor) */ ) {
            reject(`Sorry, we're out of that flavor :-(`);
        }
        resolve(sundae);
    }, Math.random() * 2000);
});
----

So the reject method is used when the request could not be completed. Notice that even 
though the request failed, we can still return data, so in this case we're just returning an error message: [underline]#Sorry, we're out of that flavor#.

A promise constructor takes a function that will run and then, after some amount of time, will either complete 
successfully (using the *resolve* method) or unsuccessfully ( using the *reject* method). When the outcome has been finalized whether it was successful or not, the promise 
is now _fulfilled_ and will notify us so we can decide what to do with the response. 

''''

*Promises Return Immediately*

The first thing to understand is that a Promise will immediately return an object.

----
const myPromiseObj = new Promise(function (resolve, reject) {
    // sundae creation code
});
----

The object that the Promise created is the *.then()* method. It is a way we can use to have it notify us if 
the request we made in the promise was either successful or failed.  +

[underline]#The *.then()* method takes two functions:#

* The function to run if the request completed successfully.

----
mySundae.then(function(sundae) {
  console.log("Time to eat my delicious ${sundae};
},
----

* the function to run if the request failed to complete. 

----
 function(msg) {
     console.log(msg);
    }
 );
----

together would look like this: 
----
new Promise(function (resolve, reject) {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
        const sundae = {};
        // request ice cream
        // get cone
        // warm up ice cream scoop
        // scoop generous portion into cone!
        if ( /* iceCreamConeIsEmpty(flavor) */ ) {
            reject(`Sorry, we're out of that flavor :-(`);
        }
        resolve(sundae);
    }, Math.random() * 2000);
});


mySundae.then(function(sundae) {
    console.log(`Time to eat my delicious ${sundae}`);
}, function(msg) {
    console.log(msg);
});
----

== 8.19 : More Promises

This video is dedicated to tell you that you can learn more about *Promises* through their 
extra course: link:https://www.udacity.com/course/javascript-promises--ud898[Udacity JavaScript Promises]

There are benefits to Promises.. such as: 

* They make it easier to do *asynchronous* code. 
* The code will be easier to read and write.
* Easier to debug.

The class will also help us build an app called "Exoplanet explored"(sp). 


== 8.20 : Proxies Intro

In the dictionary, A proxie is something that represents someone else. +
But in ES6 A Proxie is letting an object stand in for another object to handle all the interactions for that other object. 

* The proxie can handle requests directly 
* pass data back and forth to the target object
* and more. 

== 8.21 : Proxies

To create a *proxy object*, we use the Proxy constructor *new Proxy();*. The proxy constructor 
takes two items: 

* the object that it will be the proxy for. 
* the object containing the list of methods it will handle for the proxied object. 

The second object is called the handler. 

''''
=== A Pass Through Proxy 

The simplest way to create a proxy is to provide an object and then an empty handler object. 

----
var richard = {status: 'looking for work'};
var agent = new Proxy(richard, {});
----

When you check the status of agent by typing in 

----
agent.status;
----

You should get the message: 

----
"looking for work"
----

So far the code doesn't do anything special with the proxy, but it does pass the request 
directly to the source object. If we want the proxy object to actually intercept the request, 
that's what the handler object is for.

The key to making Proxies useful is the handler object that's passed as the second object to the Proxy 
constructor. The handler object is made up of a method's that will be used for 
property access. Let's look at th *get*:

== 8.22 : Proxies vs ES5 Getter/Setter
== 8.23 : Proxies Recap
== 8.24 : Generators
== 8.25 : Generators & Iterators
== 8.26 : Sending Data into/out of a Generator
== 8.27 : Lesson 3 Summary