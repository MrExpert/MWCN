:library: Asciidoctor
:toc:
:toc-placement!:


= Grow with Google Challenge Notes: Chapter 8 aka Lesson 3

Built-Ins notes +
To go back to the README where all the chapters are: click link:README.asciidoc[here].


toc::[]

== 8.1 : New Built-Ins 

These are the new Built-Ins that were put in with ES6

* Sets
* Maps 
* Promises
* and more...

These built-ins will make it much easier to execute tasks that were more difficult before. In this lesson we are going to:

* See how the new built-ins are structured
* See how the new built-ins work.
* and when to use these new built-ins.

== 8.2 : Symbols Intro

Symbols is a new addition to the primitive data type in JavaScript.

Here are the current primitive data types:
====

* numbers 
* String 
* booleans
* null
* undefined
* symbols
====

So what is Symbol?

Symbol is a unique idenitfier, most used to uniquely identify properties within an object.

Example:
Bowl has 2 bananas, 1 orange, and 1 apple.

Symbol will help identify each of those bananas as banana1 and banana2, but it'll be easier. We'll see!

== 8.3 : Symbols



To create a symbol, we write *Symbol()* with an optional string as its description.

----
const sym1 = Symbol('apple');
----

Adding a description *'apple'* is just a way to describe the symbol, but it can't be used to access the symbol itself.

To show how it works, we'll compare the two symbols with the same description.

----
const sym2 = Symbol('banana');
const sym3 = Symbol('banana');
console.log(sym2 === sym3);
----

The result will be *false* because the description has no effect on the symbol itself but for description only.

''''

Here's to show how a symbol can be useful.

----
const bowl = {
  'apple': { color: 'red', weight: 136.078 },
  'banana': { color: 'yellow', weight: 183.151 },
  'orange': { color: 'orange', weight: 170.097 },
  'banana': { color: 'yellow', weight: 176.845 }
};

console.log(bowl);
----

When we run this, the second banana will overwrite the first banana.

This is the output for *console.log(bowl)*:
====
----
{ apple: { color: 'red', weight: 136.078 },
  banana: { color: 'yellow', weight: 176.845 },
  orange: { color: 'orange', weight: 170.097 } }
----
====

''''
To fix this problem, we have to use Symbols.

Here is how we'd write it:
----
const bowl = {
  [Symbol('apple')]: { color: 'red', weight: 136.078 },
  [Symbol('banana')]: { color: 'yellow', weight: 183.15 },
  [Symbol('orange')]: { color: 'orange', weight: 170.097 },
  [Symbol('banana')]: { color: 'yellow', weight: 176.845 }
};
console.log(bowl);
----

will print out: 
====
----
{ [Symbol(apple)]: { color: 'red', weight: 136.078 },
  [Symbol(banana)]: { color: 'yellow', weight: 183.15 },
  [Symbol(orange)]: { color: 'orange', weight: 170.097 },
  [Symbol(banana)]: { color: 'yellow', weight: 176.845 } }
----
====

because when the properties use symbols, each property is a unique Symbol and the first banana doesn't get overwritten by the second banana anymore.


== 8.4 : Iteration & Iterable Protocols

Before we continue on, the instructors want us to understand these new protocols in ES6. 

* the *iterable* protocol
* the *iterator* protocol

=== The Iterable Protocol 

Let's start with Iterable.

What the iterable protocol does is define and customize the iteration behavior of objects. +
Which means we now have the flexibility in ES6 to specify a way for iterating through values in an object.

Before, strings and arrays had built-in iterables. +

Code refresher: Array built-in iterable
----
const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for (const digit of digits) {
  console.log(digit);
}
----

will print:
----
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
----

Later in this lesson, they'll cover more on that and also more built-in iterables like *Sets* and *Maps*.

''''
When we were learning *for...of* loops, they said that objects can be iterated _only_ if they're *iterable*. +
To make an object iterable, we have to implement the *iterable interface*. +
The *iterable interface* means it must contain a *default iterator method*. This method will define how the object should be iterated.

So now we have to understand what the *iterator method* is...

=== The Iterator Protocol 

The iterator method is available through constant: *[Symbol.iterator]* is a zero arguments function 
that returns an iterator object. +
An iterator object is an object that follows the rules of the iterator protocol.

The iterator protocol has a process for defining how an object will iterate. This is done through using the *.next()* method.

The object becomes an iterator when it implements the *.next()* method. The *.next()* method is a zero arguments function that returns an object with [underline]#two properties#.

The two properties: 

. *value* : the data representing the value that was used for the *.next()* method.
. *done* : a [underline]#boolean# representing if the iterator is _done_ going through the sequence of values.
  * If done is *true*, then the iterator has reached the end of its sequence of values.
  * If done is *false*, then the iterator is able to produce another value in its sequence of values.

Here is how to write an iterator using an array. I made it shorter than the example that way we can see done as *true* and *false*

----
const digits = ['can1', 'can2', 'can3'];
const arrayIterator = digits[Symbol.iterator]();

console.log(arrayIterator.next());
console.log(arrayIterator.next());
console.log(arrayIterator.next());
console.log(arrayIterator.next());
----

This will print out: 

====
----
{ value: 0, done: false }
{ value: 1, done: false }
{ value: 2, done: false }
{ value: undefined, done: true }
----
====


== 8.5 : Sets

A set in mathematics is something like this: {2, 4, 5, 6} +
because each of the numbers in the collection are unique. + 

However...
{1, 1, 2, 3} is not a set because it contains *duplicate* entries. [underline]#1# appears more than once.

JavaScript on the other hand, doesn't care and will let you have duplicated entries.
However, doing so will break the [underline]#mathematical# set rule.

Now if you want JavaScript to follow the mathematical set rule, you need to use *new Set()*. +
Sets lets you add or remove items, and loop, but each of the items have to be unique.

''''

Here's how to create a set: 
----
const games = new Set();
console.log(games);
----

will print out an empty Set games with no items.
====
set {}
====

''''

If you want to create a Set from a list of values, you can use an array:

----
const games = new Set(['Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart', 'Super Mario Bros.']);
console.log(games);
----

prints out: 
====
----
Set { 'Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart' }
----
====

In this example, the duplicate object was automatically removed. In this case, it removed "*Super Mario Bros"*.


=== Sets quiz 

This quiz wants to check if you've been paying attention.

Reminder: Sets is a collection of values that has to be unique.

====
Option 1: {1, 'Basketball', true, false, '1'}

Option 2: {}

Option 3: {1, 1, 1, 1}

Option 4: {false, '0', 0, 'Soccer', 3.14, 25, 0}

Option 5: {'Gymnastics', 'Swimming', 2}
====

Answer:  They put in different data types to try and trick you. So a number 1 and a string 1 are considered unique from each other. So the answers are Options 1, 2, and 5.

== 8.6 : Modifying Sets

now that we know how to create sets, now we can learn how to use them.

Using this set:
----
const games = new Set(['Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart', 'Super Mario Bros.']);
----

Here's how to *add* to the set:

----
games.add('Banjo-Tooie');
----

If we print it out with console.log(games); we would get: 
----
Set {
  'Super Mario Bros.',
  'Banjo-Kazooie',
  'Mario Kart',
  'Banjo-Tooie' }
----
with our new *Banjo-Tootie* at the very bottom.



''''
If we wanted to *delete*, we type in:

----
games.delete('Super Mario Bros.');
----

our new result would be:
----
Set { 'Banjo-Kazooie', 'Mario Kart', 'Banjo-Tooie' }
----



''''

If we want to delete all of the items from the Set, we can simply use the *.clear()* method.

----
games.clear()
----

prints the familiar empty Set.
----
Set {}
----
''''
[NOTE]
====
* If you try to *.add()* an item that is already in the set, you will not receive an error, instead the item will just be ignored. +
    . The .add() will return the *Set* if an item was successfully added.
* If you try to *.delete()* an item that is not in the set, you will not receive an error, instead the command will just be ignored.
    . The .delete() returns a Boolean depending on successful deletion.
====

== 8.7 : Working with Sets
There are a number of different properties and methods we can use to work with sets.

=== Checking the Length

Now that we've made a Set, we want to see how many items are in it. +
here, we use: *.size* property.

Here's how to use it 
----
const months = new Set(['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']);
console.log(months.size);
----
This will print out: *12*.

NOTE: Sets can't be accessed by their index like an array, so you use the .size property instead of .length property to get the size of the Set.

=== Check if an Item Exists.

To check if an item exists in the Set, we use *.has()* method.

* If the item is in the set, then .has() will return *true*.
* If the item is NOT in the set, then .has() will return *false*.

To use:
----
console.log(months.has('September'));
----

will print: *true*

=== Retrieving all Values

If we want to return all the values in a Set, we use the *.values()* method. The returned values from *.values()* method is a *SetIterator* object.

Here's how to use:
----
console.log(months.values());
----

You get a *SetIterator* with a lists of the months in {}. 

NOTE: SetIterator is shown empty on sites like JSBin and Repl.it. however, if you use it in devtools, you can really see the details and what's inside.
Here's a screen shot of using just *months* vs *months.values()* +
image:img/sets1.png[] +

''''

Another note is that .keys() method behaves the same way as .values() method by returning the values of a Set within a new iterator Object.
The .keys() method is an alias for the .values() method for similarity with maps. We will get more into .keys() when when we cover maps.

== 8.8 : Sets & Iterators

Because the *.values()* method returns a new iterator object called *SetIterator*, you can store that iterator object in a variable and loop through each item in the Set using .next().

----
const iterator = months.values();
iterator.next();
----

will print: *Object {value: 'January', done: false}* +
If you type *iterator.next()* again, you will get *{'February', done: false}*. This will keep going until *done: true*.

''''

There's an easier way to loop through the items in a Set, and that is to use the *for...of loop*.

----
const colors = new Set(['red', 'orange', 'yellow', 'green', 'blue', 'violet', 'brown', 'black']);
for (const color of colors) {
  console.log(color);
}
----

Which will print: 
----
red
orange
yellow
green
blue
violet
brown
black
----
== 8.9 : Quiz: Using Sets

=== Refresher for the quiz
This was a long subject so maybe a refresher is needed.

Code Refresher: 
====
*Here's how to create a set:*
----
const name = new Set();
----
====

====
*Here's how to add an item into the set*

----
name.add('item1')
----
====

====
*Here's how to delete an item from the set*

----
name.delete('item2')
----
====

''''
=== Using Sets Quiz 

* They want you to create a set with the name: *myFavoriteFlavors*

* They want you to add in these strings: 
    . "chocolate chip"
    . "cookies and cream"
    . "strawberry"
    . "vanilla"
* They want you to delete this item from the set:
    . "strawberry"

''''

Answer 
====
----
const myFavoriteFlavors = new Set();

myFavoriteFlavors.add('chocolate chip');
myFavoriteFlavors.add('cookies and cream');
myFavoriteFlavors.add('strawberry');
myFavoriteFlavors.add('vanilla');
myFavoriteFlavors.delete('strawberry')

console.log(myFavoriteFlavors)
----
====


== 8.10 : WeakSets

WeakSet is like a normal Set but it's different in these ways:

* WeakSet can only contain *objects*.
* WeakSet is *not iterable* which means it cannot be looped over.
* WeakSet does not have a *.clear()* method.


To create a Weakset, you do the same thing as a normal Set.

----
const roster = new WeakSet();
----

However, like what was mentioned earlier, it only accepts objects.

Objects:
----
const student1 = { name: 'James', age: 26, gender: 'male' };
const student2 = { name: 'Julia', age: 27, gender: 'female' };
const student3 = { name: 'Richard', age: 31, gender: 'male' };
----

New Weaksets:
----
const roster = new WeakSet([student1, student2, student3]);
console.log(roster);
----

If you try to add a string inside the weakset like this:

----
roster.add('Amanda');
----

You get the error:

----
Uncaught TypeError: Invalid value used in weak set(…)
----

=== WeakSet's purpose

If Sets can have many datatypes and WeakSets can only have Objects, then why do we need WeakSets?

The reason is because of the *.clear()* method.

=== Garbage Collection

In JavaScript, memory is allocated when new values are created and is "automatically" freed up when
those values are no longer needed. This process of freeing up memory after it is no longer needed is what is known 
as *garbage collection*.

WeakSets take advantage of this by exclusively working with objects. If you set an object to *null*, then
you're essentially deleting the object. And when JavaScript's *garbage collector* runs, the
memory that object previously occupied will be freed up to be used later in your program.


For example:

====
----
student3 = null 
console.log(roster);
----

Will print out: +
*WeakSet {Object {name: 'Julia', age: 27, gender: 'female'}, Object {name: 'James', age: 26, gender: 'male'}}*

====

What makes WeakSet suseful is that you don't have to worry about deleting references to deleted objects in your
weakSets, because JavaScript does it for us. When an object is deleted, the object will also 
be deleted from the WeakSet when garbage collection runs. *This makes WeakSet useful in 
situations where you want an efficient, lightweight solution for creating groups of objects*.


== 8.11 : Quiz: Working With WeakSets 

Quiz Time!
=== Refresher
Just in case you need a refresher!

====
*To add a WeakSet*
----
const name = new WeakSet()
----
====

====
*to add an object into a WeakSet*
----
One Object: 

name.add(object1);

More than one Object: 

name.add([object1, object2, object3])

----
====

=== Quiz: Working With WeakSets 

NOTE: Keep in mind that they want you to add the objects one by one. So there should be 3 .add().

* Create a WeakSet with the name *uniqueFlavors*
* create an object with the name *flavor1* with the properties: *{flavor: 'chocolate'}*
* create an object with the name *flavor2* with the properties: *{flavor:}* Give the value of flavor whatever you want.
* use the *.add()* method to add the objects *flavor1* and *flavor2* to *uniqueFlavors*.
* use the *.add()* method to add *flavor1* to *uniqueFlavors* WeakSet, again.

Answer
====
----
const uniqueFlavors = new WeakSet();

const flavor1 = {flavor: 'chocolate'};
const flavor2 = {flavor: 'chocolate chip'};


uniqueFlavors.add(flavor1);
uniqueFlavors.add(flavor2);
uniqueFlavors.add(flavor1);

console.log(uniqueFlavors)
----
====

== 8.12 : Maps

Introducing Maps and WeakMaps. 

Maps and WeakMaps are actually similar. 

====
Here is what they have in common:

* They have similar properties. 
* Maps and Sets are both iterable. Which means we can loop over them.
* WeakMaps and WeakSets don't prevent garbage collection.
====

====
Here is what Maps and WeakMaps has that's different.

* Maps are collections of key-value pairs while Sets are collections of unique values.

example:
----
Maps 

        {
            key1: value1
            richard: 'is awesome'
            james: 'wants to be cool like richard'
        }

Sets are collections of unique values

        [val1, val2, val3]
----
A nice way to see them is *Sets::Arrays* and *Maps::Objects*
====



== 8.13 : Creating & Modifying Maps

Essentially, a Map is an object that lets you store key-value pairs when both the keys and the values can be
objects, primitive values, or a combination of the two.

=== Here's how to create a Map 

To create a Map, type:

----
const employees = new Map();
----

If we console.log this, it would print out: *Map {}* Employee will be created with no key-value pairs.

=== Modifying Maps 

==== Adding to a Map

====


Unlike Sets, you can't create Maps from a list of values; instead, you add key-values
by using the Map's *.set()* method.

----
const employees = new Map();

employees.set('james.parkes@udacity.com', { 
    firstName: 'James',
    lastName: 'Parkes',
    role: 'Content Developer' 
});
employees.set('julia@udacity.com', {
    firstName: 'Julia',
    lastName: 'Van Cleve',
    role: 'Content Developer'
});
employees.set('richard@udacity.com', {
    firstName: 'Richard',
    lastName: 'Kalehoff',
    role: 'Content Developer'
});

console.log(employees);
----

It will print out: +
image:img/map1.png[] +
The *.set()* method takes two arguments. The first argument is the [underline]#key#, which is used to reference the second argument, which is [underline]#value#.

NOTE: When you use the *.set()* on a key-value pair to a Map that already uses the same key, you
won't receive an error, but the key-value pair will overwrite what currently exists in the Map. +
The return value of *.set()* is the Map object itself if the operation was successful.

====

==== Deleting from a map. 

====
If you want to remove [underline]#key-value# pair(s), simply use the *.delete()* method.

----
employees.delete('julia@udacity.com');
employees.delete('richard@udacity.com');
----

now it will only print out:

----
Map {
  'james.parkes@udacity.com' => { firstName: 'James',
  lastName: 'Parkes',
  role: 'Content Developer' } }
----

NOTE: If you try to *.delete()* a key-value pair that is not in a Map, you won't receive an error, and the
Map will remain unchanged. +
Just like in [underline]#Sets#, .delete() method returns true if a key value pair is succesfully deleted
from the Map object, and false if unsuccessful.
====

=== Remove all 

====
Similar to Sets, you can use the *.clear()* method to remove all key-value pairs from the Map.

----
employees.clear()
----

will print out an empty Map:

----
Map {}
----
====


== 8.14 : Working with Maps

=== Checking your Map 
====
To check to see if a [underline]#key-value# pair exists inside the Map, use *.has()*.

----
const members = new Map();

members.set('Evelyn', 75.68);
members.set('Liam', 20.16);
members.set('Sophia', 0);
members.set('Marcus', 10.25);

console.log(members.has('Xavier'));
console.log(members.has('Marcus'));
----

You would get the results:

* *false* for [underline]#Xavier#
* *true* for [underline]#Marcus#
====

=== Retrieving values 

====
If you need to retrieve a Value from a Map, you need to pass in its *key* using the *get()* method.

----
console.log(members.get('Evelyn'));
----

Should get this result:

----
75.68
----
====


== 8.15 : Looping Through Maps

We have 3 different ways to loop through Maps.

* Step through each key or value using the *Map's default iterator*
* Loop through each key-value pair using the new *for...of* loop 
* Loop through each key-value pair using the Map's *.forEach()* method.

Let's check them out one by one.

=== MapIterator

Using both the *.keys()* and *.values()* methods on a Map will return a new iterator object
called *MapIterator*. +
You can store that iterator object in a new variable and use *.next()* to 
loop through each key or value. +
Depending on which method you use, it will determine if your iterator 
has access to the Map's keys or the Map's values.

----
let iteratorObjForKeys = members.keys();
iteratorObjForKeys.next();
----

will return 
----
Object {value: 'Evelyn', done: false}
----

You can keep using *.next()* until [underline]#done# is *true*

----
let iteratorObjForKeys = members.keys();
iteratorObjForKeys.next();
{value: "Evelyn", done: false}
iteratorObjForKeys.next();
{value: "Liam", done: false}
iteratorObjForKeys.next();
{value: "Sophia", done: false}
iteratorObjForKeys.next();
{value: "Marcus", done: false}
iteratorObjForKeys.next();
{value: undefined, done: true}
----

=== Using for...of Loop

This is the familiar *for...of* loop to be used with *Maps*.

----
for (const member of members) {
  console.log(member);
}
----

will print out: 
+
image:img/map2.png[] +

Though, when using *for...of* loop with a Map, you don't exactly get back a *key* or a *value*.
Instead, the key-value pair is split up into an array where the first element is the *key* and 
the second element is the value.  

What you need to do is use the *array deconstructuring inside the for...of loop*.

=== Quiz: 

====

Code Refresher:


Array Destructuring 
----
var x = [1, 2, 3, 4, 5];
var [y, z] = x;
----
====

====
Using array destructuring to fix the following code to print the keys and values of the 'members' Map
to the console.
----
for (const member of members) {
    console.log(member)
}
----
====

Answer 
====
----
for (const [key, value] of members) {
    console.log(key, value)
}

----

which will print out + 
image:img/map3.png[]
====

Did you know that *for...of* loops support destructuring? I didn't. Here's a tiny bit of information
on it (and I really mean *tiny*): link:http://2ality.com/2015/01/es6-destructuring.html#examples-of-destructuring[destructuring with for...of loop]

----
for (const [key, value] of members) {
    console.log(`${key} has ${value}`)
}
----

=== Using the forEach Loop
Just when I learned about deconstructing for...of loops, turns out there's an easier method.

Introducing the *forEach* loop. 

Here's how to use it: 

----
members.forEach((key, value) => console.log(key, value));
----

will print out: 

image:img/map4.png[]

Okay, something funky is going on here.... I'll check back later on this.... +
AND I'm back. Apparently, values show first when it comes to iterating maps.

[NOTE]
====
When we wrote in *.forEach(key, value)*  [underline]#key, value# wasn't a deconstructoring thing, it was just an argument for the map in this order:

. the element value
. the element key
. the Map object being traversed

So if we wanted the argument to be accurate, it should have been written like this: +
 *.forEach(value, key)*

More on that here: link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach[MDN]
====

Okay, I think we can move on now!

== 8.16 : WeakMaps

A WeakMap is just like a normal Map with a few differences such as:

* a WeakMap can only contain objects as keys
* a WeakMap is *not* iterable which means it can't be looped and 
* a WeakMap does not have a .clear() method.

=== Creating WeakMaps 

You create it the same as you would Set, WeakSet, and Map. 

----
const library = new WeakMap()
----

You also add in the same way as *Map* by using *.set()*. 

----
const book1 = { title: 'Pride and Prejudice', author: 'Jane Austen' };
const book2 = { title: 'The Catcher in the Rye', author: 'J.D. Salinger' };
const book3 = { title: 'Gulliver’s Travels', author: 'Jonathan Swift' };
----

Test it out with this: 

----
library.set(book1, true);
library.set(book2, false);
library.set(book3, true);

console.log(library);
----

Should get this result: +
image:img/map5.png[]

''''
However, if you try to add something other than an *object* as key, you'll get an error.

----
library.set('The Grapes of Wrath', false);
----

You will get this error: +
image:img/map6.png[] +

We get this error because *WeakMap* can only contain objects as keys. Again, similar to 
WeakSets, weakMaps leverage garbage collection for easier use and maintainability. 


NOTE: WeakMap's Garbage collection is very identical to *WeakSet's Garbage Collection*. If you need a refresher,
scroll up: link:ch8.asciidoc#garbage-collection[garbage collection].

== 8.17 : Promises Intro

James and Richard show a real life scenario of what *Promises* are.

JavaScript is a new way of handling *asynchronous* requests.


*In Summary:* +
Making a request for something and the downtime waiting for that request to be fulfilled and being able to do
other work while we wait and then later be notified when the request is finished is what *promises* does for us in 
JavaScript.

== 8.18 : Promises

=== Creating Promises 

Promises are created with the Promise constructor function *new Promise()*. A promise
will let you start some work that will be done *asynchronously* and let you get back to 
your regular work. When you create the promise, you must give it the code that will be 
run asynchronously. You provide this code as the argument of the constructor function: 


----
new Promise(function () {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
        const sundae = {};
        // request ice cream
        // get cone
        // warm up ice cream scoop
        // scoop generous portion into cone!
    }, Math.random() * 2000);
});
----

This code creates a promise that will start in a few seconds after I make a request. Then there are 
a number of steps that need to be made in the *createSundae* function. The way I see it, it's 
similar to when James was waiting for Richard to place an order. 

=== Indicated a successful request or a Failed Request 

But once that's all done, we need a way for JavaScript to tell us that the request is complete.
That is when we use *resolve*. Resolve is used to indicate that this function should be 
called when the request completes successfully. Here we added *resolve* after all the requests.

----
new Promise(function (resolve, reject) {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
        const sundae = {};
        // request ice cream
        // get cone
        // warm up ice cream scoop
        // scoop generous portion into cone!
        resolve(sundae);
    }, Math.random() * 2000);
});
----

Once the sundae is successfully created, it calls the *resolve* method and passed the data 
we want to return. Such as this completed sundae. The *resolve* method is used to indicate that the request 
is complete and that it completed _successfully_.

''''

If there is a problem with the request and it couldn't be completed, then we could use the second 
function that's passed to the function. Typically, this function is stored in an identifier called 
*"reject"* to indicate that this function should be used if the request fails for some reason. This code we added 
*reject*.

----
new Promise(function (resolve, reject) {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
        const sundae = {};
        // request ice cream
        // get cone
        // warm up ice cream scoop
        // scoop generous portion into cone!
        if ( /* iceCreamConeIsEmpty(flavor) */ ) {
            reject(`Sorry, we're out of that flavor :-(`);
        }
        resolve(sundae);
    }, Math.random() * 2000);
});
----

So the reject method is used when the request could not be completed. Notice that even 
though the request failed, we can still return data, so in this case we're just returning an error message: [underline]#Sorry, we're out of that flavor#.

A promise constructor takes a function that will run and then, after some amount of time, will either complete 
successfully (using the *resolve* method) or unsuccessfully ( using the *reject* method). When the outcome has been finalized whether it was successful or not, the promise 
is now _fulfilled_ and will notify us so we can decide what to do with the response. 

''''

*Promises Return Immediately*

The first thing to understand is that a Promise will immediately return an object.

----
const myPromiseObj = new Promise(function (resolve, reject) {
    // sundae creation code
});
----

The object that the Promise created is the *.then()* method. It is a way we can use to have it notify us if 
the request we made in the promise was either successful or failed.  +

[underline]#The *.then()* method takes two functions:#

* The function to run if the request completed successfully.

----
mySundae.then(function(sundae) {
  console.log("Time to eat my delicious ${sundae};
},
----

* the function to run if the request failed to complete. 

----
 function(msg) {
     console.log(msg);
    }
 );
----

together would look like this: 
----
new Promise(function (resolve, reject) {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
        const sundae = {};
        // request ice cream
        // get cone
        // warm up ice cream scoop
        // scoop generous portion into cone!
        if ( /* iceCreamConeIsEmpty(flavor) */ ) {
            reject(`Sorry, we're out of that flavor :-(`);
        }
        resolve(sundae);
    }, Math.random() * 2000);
});


mySundae.then(function(sundae) {
    console.log(`Time to eat my delicious ${sundae}`);
}, function(msg) {
    console.log(msg);
});
----

== 8.19 : More Promises

This video is dedicated to tell you that you can learn more about *Promises* through their 
extra course: link:https://www.udacity.com/course/javascript-promises--ud898[Udacity JavaScript Promises]

There are benefits to Promises.. such as: 

* They make it easier to do *asynchronous* code. 
* The code will be easier to read and write.
* Easier to debug.

The class will also help us build an app called "Exoplanet explored"(sp). 


== 8.20 : Proxies Intro

In the dictionary, A proxie is something that represents someone else. +
But in ES6 A Proxie is letting an object stand in for another object to handle all the interactions for that other object. 

* The proxie can handle requests directly 
* pass data back and forth to the target object
* and more. 

== 8.21 : Proxies

To create a *proxy object*, we use the Proxy constructor *new Proxy();*. The proxy constructor 
takes two items: 

* the object that it will be the proxy for. 
* the object containing the list of methods it will handle for the proxied object. 

The second object is called the handler. 

''''
=== A Pass Through Proxy 

The simplest way to create a proxy is to provide an object and then an empty handler object. 

----
var richard = {status: 'looking for work'};
var agent = new Proxy(richard, {});
----

When you check the status of agent by typing in 

----
agent.status;
----

You should get the message: 

----
"looking for work"
----

So far the code doesn't do anything special with the proxy, but it does pass the request 
directly to the source object.

If we want the proxy object to actually intercept the request, that's what the handler object is for.

The handler object is made up of a method's that will be used for 
property access. Let's look at one of these properties: *get*:

=== Get Trap 

The *get* trap is used to *intercept* calls to properties: 

example: 
----
const richard = {status: 'looking for work'};
const handler = {
    get(target, propName) {
        console.log(target); // the `richard` object, not `handler` and not `agent`
        console.log(propName); // the name of the property the proxy (`agent` in this case) is checking
    }
};
const agent = new Proxy(richard, handler);
agent.status; // logs out the richard object (not the agent object!) and the name of the property being accessed (`status`)
----

In the code above...

*  *handler* object has a *get* method (called a *trap* since it's being used in a Proxy). 
* When the code *agent.status;* is run on the last line, because the *get* trap 
exists, it "intercepts" the call to get the status property and runs the *get* trap function. 

* This will log out the target object of the proxy  (richard object) and then logs out the 
name of the property being requested (the status property).

* It doesn't actually log out the property. This is important - If a trap is used, you need to make sure you 
provide all the functionality for that specific trap. 


=== Accessing the Target object from inside the proxy 

To provide the real result, we would need to return the property on the target object: 

----
const richard = {status: 'looking for work'};
const handler = {
    get(target, propName) {
        console.log(target);
        console.log(propName);
        return target[propName];
    }
};
const agent = new Proxy(richard, handler);
agent.status; // (1)logs the richard object, (2)logs the property being accessed, (3)returns the text in richard.status
----

Here they added *return target[propName];* as the last line of the *get* trap. This will access the 
property on the *target object* and will return it.

=== Have the proxy return info directly

Alternatively, we could use the proxy to provide direct feedback: 

----
const richard = {status: 'looking for work'};
const handler = {
    get(target, propName) {
        return `He's following many leads, so you should offer a contract as soon as possible!`;
    }
};
const agent = new Proxy(richard, handler);
agent.status; // returns the text `He's following many leads, so you should offer a contract as soon as possible!`
----

With this code, the Proxy doesn't even check the target object, it just directly 
responds to the calling code. 

So the *get* trap will take over whenever any property on the proxy is accessed.


=== Intercept calls to change properties

If we want to intercept calls to _change_ properties, then the *set* trap needs to be used! 

The *set* trap is used for intercepting code that will change a property. The *set* trap receives the object 
it proxies the property that is being set the new value for the proxy. 

----
const richard = {status: 'looking for work'};
const handler = {
    set(target, propName, value) {
        if (propName === 'payRate') { // if the pay is being set, take 15% as commission
            value = value * 0.85;
        }
        target[propName] = value;
    }
};
const agent = new Proxy(richard, handler);
agent.payRate = 1000; // set the actor's pay to $1,000
agent.payRate; // $850 the actor's actual pay
----

In the code above notice that the *set* trap checks to see if the *payRate* property is being set. 
If it is, then the proxy (the agent) takes 15 percent off the top of her own commission. Then, when the actor's pay is 
set to one thousand dollars, since the payRate property was used, the code took 15% off the top and set 
the actual *payRate* property to *850*.


=== Other Traps
All we've looked at was *get* and *set* traps. There are 13 traps that can be used inside the handler.

The two that we covered: 

====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get[get] trap - lets the proxy handle calls to property access.

Syntax 
----
var p = new Proxy(target, {
  get: function(target, property, receiver) {
  }
});
----

Takes 3 Parameters 

* target - the target object 
* property - The name of the property to get 
* receiver - Either the proxy or an object that inherits from the proxy.

''''
Return Value - The *get* method can return any value.
====

====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set[set] trap - lets the proxy handle setting the property to a new value.

Syntax 

----
var p = new Proxy(target, {
  set: function(target, property, value, receiver) {
  }
});
----

Takes 4 Parameters 

* target - The target object 
* property - The name of the property to set 
* value - The new value of the property to set. 
* receiver - The object to which the assignments was originally directed. This is usually the proxy itself.

''''
Return Value - The *set* method should return a boolean value. Return *true* to indicate that assignment succeeded. If the *set* method returns *false*, and the assignment 
happened in _strict-mode code_, a *TypeError* will be shown.
====
The others that weren't covered. 
====

* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply[apply] trap - lets the proxy handle being invoked (the object being proxied is the function).

syntax: 
----
var p = new Proxy(target, {
  apply: function(target, thisArg, argumentsList) {
  }
});
----

Takes 3 parameters

. target - the target object 
. thisArg - the this argument for the call.
. argumentsList - the list of arguments for the call.

''''
Return Value - the *apply* method can return any value.
====
====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has[has] trap - The handler.has method is a trap for the *in* operator.

syntax: 
----
var p = new Proxy({}, {
  has: function(target, prop) {
    console.log('called: ' + prop);
    return true;
  }
});

console.log('a' in p); // "called: a"
                       // true
----

Takes 2 parameters

. target - the target object
. prop - the name of the property to check for existence.

''''
Return Value - the *has* method must return a boolean value.

====


====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/deleteProperty[deleteProperty] trap - lets the proxy handle if a property is deleted.

syntax
----
var p = new Proxy(target, {
  deleteProperty: function(target, property) {
  }
});
----

Takes 2 parameters.

. target - the target object. 
. property - the name of the property to delete

''''
Return Value - of *deleteProperty* method must return a *Boolean* indicating whether or not the property has been successfully deleted.

====

====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/ownKeys[ownKeys] trap - lets the proxy handle when all keys are requested.

syntax
----
var p = new Proxy(target, {
  ownKeys: function(target) {
  }
});
----

Takes 1 parameter.

* target - the target object

''''
the *ownKeys* method must return an enumerable object. +

====

====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct[construct] trap - lets the proxy handle when the proxy is used with the *new* keyword as a constructor.

syntax
----
var p = new Proxy(target, {
  construct: function(target, argumentsList, newTarget) {
  }
});
----

Takes in 3 parameters 

* target - the target object 
* argumentsList - the list of arguments for the constructor.
* newTarget - the constructor that was originally called like *p* above.

''''
Return Value - The construct method must return an object.

====

====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/defineProperty[defineProperty] trap - let the proxy handle when defineProperty is used to create a new property on the object. 

syntax 
----
var p = new Proxy(target, {
  defineProperty: function(target, property, descriptor) {
  }
});
----

Takes 3 parameters 

* target - the target object.
* property - the name of the property whose description is to be retrieved.
* descriptor - the descriptor for the property being defined or modified.

''''
Return Value - the *defineProperty* method must return a *Boolean* indicating whether or not the property has been successfully defined.

====

====

* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor[getOwnPropertyDescriptor] - lets the proxy handle when defineProperty is used to create a new property on the object.

Syntax
----
var p = new Proxy(target, {
  getOwnPropertyDescriptor: function(target, prop) {
  }
});
----

Takes 2 Parameters 

* target - the target object 
* prop - The name of the property whose description should be retrieved. 

''''
Return Value - The *getOwnPropertyDescriptor* method must return an object or undefined.

====
====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/preventExtensions[preventExtensions] trap - lets the proxy handle calls to *Object.preventExtensions()* on the proxy object. 

Syntax 
----
var p = new Proxy(target, {
  preventExtensions: function(target) {
  }
});
----

takes in 1 parameter 

* target - the target object 

''''
Return Value - the *preventExtensions* method must return a boolean value.

====

====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible[isExtensible] trap - lets the proxy handle calls to *Object.isExtensible* on the proxy object.

Syntax 
----
var p = new Proxy(target, {
  isExtensible: function(target) {
  }
});
----

Takes 1 Parameter 

* target - the target object 

''''
Return Value - The *isExtensible* method must return a boolean value.

====

====

* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf[getPrototypeOf] trap - lets the proxy handle calls to *Object.getPrototypeOf* on the proxy object.

Syntax

----
var p = new Proxy(obj, {
  getPrototypeOf(target) {
  ...
  }
});
----

Takes 1 parameter 

* target - the target object

''''
Return Value - The *getPrototypeOf* method must return an object or null.

====

====
* link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/setPrototypeOf[setPrototypeOf] trap - lets the proxy handle calls to *Object.setPrototypeOf* on the proxy object.

Syntax 
----
var p = new Proxy(target, {
  setPrototypeOf: function(target, prototype) {
  }
});
----

Takes 2 Parameters 

* target - the target object 
* prototype - the object's new prototype or null

''''
Return Value - The *setPrototypeOf* method returns *true* if the \[[Prototype]] was successfully changed, otherwise *false*.

====

== 8.22 : Proxies vs ES5 Getter/Setter

Here's an example of getter/setter that will do the same thing as proxies. 

----
var obj = {
    _age: 5,
    _height: 4,
    get age() {
        console.log(`getting the "age" property`);
        console.log(this._age);
    },
    get height() {
        console.log(`getting the "height" property`);
        console.log(this._height);
    }
};
----

With Get/Set we have to set *get age()* and *get height()* when initializing the object. 
So when we call the code below, we'll get the following results: 

----
obj.age; // logs 'getting the "age" property' & 5
obj.height; // logs 'getting the "height" property' & 4
----

But when we add a new property to the object... 
----
obj.weight = 120; // set a new property on the object
obj.weight; // logs just 120
----

Notice that a *getting the "weight" property* message wasn't displayed like the age and height properties produced.

With ES6 Proxies, we do not need to know the properties beforehand:

----
const proxyObj = new Proxy({age: 5, height: 4}, {
    get(targetObj, property) {
        console.log(`getting the ${property} property`);
        console.log(targetObj[property]);
    }
});

proxyObj.age; // logs 'getting the age property' & 5
proxyObj.height; // logs 'getting the height property' & 4
----

Now if we do the same thing like with ES5 and add a new property 

----
proxyObj.weight = 120; // set a new property on the object
proxyObj.weight; // logs 'getting the weight property' & 120
----

Here A *weight* property was added to the proxy object, and when it was later retrieved, 
it displayed a log message. 

So some functionality of proxy objects may seem similar to existing ES5 getter/setter methods. But with 
proxies, you do not need to initialize the object with getters/setters for each property when the object is initalized.



== 8.23 : Proxies Recap

A proxy object sits between a real object and the calling code. The calling code 
interacts with the proxy instead of the real object. To create a proxy: 

* use the *new Proxy()* constructor.
    . pass the object being proxied as the first item. 
    . the second object is a handler object. 
* the handler object is made up of 1 of 13 different "traps"
* a trap is a function that will intercept calls to properties let you run code
* if a trap is not defined, the default behavior is sent to the target object. 

Proxies are a powerful new way to create and manage the interactions between objects.

== 8.24 : Generators

Whenever a *function* is invoked, the javaScript engine starts at the top of 
the function and runs every line of the code until it gets to the bottom. 

There's no way to stop the execution of the function in the middle and pick up again at some later point. 

This *run to completion* is the way it's always been: 

----
function getEmployee() {
    console.log('the function has started');

    const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

    for (const name of names) {
        console.log(name);
    }

    console.log('the function has ended');
}

getEmployee();
----
prints: 

image:img/gen.png[] +

'''
But what if you want to print out the first 3 employee names then stop for a bit, then, at some later point, 
you want to continue where you left off and print out more employee names. With a regular function, 
you can't do this since there's no way to *pause* a function in the middle of its execution. 

=== Pausable Functions 

If we do want to be able to pause a function mid-execution, then we'll need a new type of function available 
to us in ES6 - *generator functions!* Let's look at one: 

----
function* getEmployee() {
    console.log('the function has started');

    const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

    for (const name of names) {
        console.log( name );
    }

    console.log('the function has ended');
}
----

The asterisk after function ( function* ) indicates that this function is actually a *generator*!

Now when we run that code with this

----
getEmployee();
----

It prints: 

image:img/gen2.png[]

Now the question is where are all the text from the top of the function and how come we didn't 
get any names printed to the console? 


=== Function Generator Quiz 

NOTE: You can place the asterisk anywhere in between function and name 

Question: +
Which of the following are valid generators? Pay attention to the placement of the asterisk.

====
----
Option 1: function* names() {...}
Option 2: function * names() {...}
Option 3: function *names() {...}
----
====

Answer: All of them

== 8.25 : Generators & Iterators

Continuing from the previous section and its problem...

When a generator is invoked, it doesn't actually run any of the code inside the function. 
Instead, it creates and returns an iterator. This iterator can then be used to execute the actual generator's inner code. 

image:img/gen3.png[]

''''
When we used .next(), it printed out everything and the code never paused. We're kind of back to square one...

=== The Yield Keyword 

The yield keyword is new and was introduced with ES6. it can only be used inside generator 
functions. *yield* is what causes the generator to pause. Let's put it in the code. 

----
function* getEmployee() {
    console.log('the function has started');

    const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

    for (const name of names) {
        console.log(name);
        yield;
    }

    console.log('the function has ended');
}
----

When we put in

----
const generatorIterator = getEmployee();
generatorIterator.next();
----

We get: 

----
the function has started
Amanda
----

It's paused there. If we put in another *generatorIterator.next()* we get: 
----
Diego
----

It remembered where we left off. If we keep doing .next(), it will keep going till it's finished. 

=== Yielding Data to the "Outside" World

Instead of logging the names to the console and then pausing, let's have the code *return* the name and then pause.

----
function* getEmployee() {
    console.log('the function has started');

    const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

    for (const name of names) {
        yield name;
    }

    console.log('the function has ended');
}
----

The difference here is that the for...of loop's no longer has console.log(name) but has *yield name* instead.

=== Yield Quiz 

Question: 

How many times will the iterator's .next() method need to be called to fully complete/"use up" the 
udacity's generator function below:

----
function* udacity() {
    yield 'Richard';
    yield 'James'
}
----

Answer: 3 times

NOTE: It will be called one more time than there are *yield* expressions in the generator function. 
The first call to *.next()* will start the function and run to the first *yield*. The second call to *.next()* will pick up where things left off 
and run to the second *yield*. The third and final call to *.next()* will pick up where things left off again and run to the end of the function. 

== 8.26 : Sending Data into/out of a Generator

Previous lessons on generators [underline]#was sending data out#. This will be about *sending data back into the generator*! We do this 
with the *.next()* method: 

----
function* displayResponse() {
    const response = yield;
    console.log(`Your response is "${response}"!`);
}

const iterator = displayResponse();
----

When you put in this *.next()* method with it 

----
iternator.next(); // This starts running the generator function
iterator.next('Hello Udacity Student');  // This sends data into the generator. 
----

you get: +
image:img/gen4.png[] +

Calling *.next()* with data (ie *.next('Richard')*) will send data into the generator function where it last left off. It will *replace* the yield keyword with the data that you provided.

So the *yield* keyword is used to pause a generator and used to send data outside of the generator, and 
then the *.next()* method is used to pass data into the generator.

=== Quiz 

What will happen if you run this code: 

----
function* createSundae() {
    const toppings = [];

    toppings.push(yield);
    toppings.push(yield);
    toppings.push(yield);

    return toppings;
}

var it = createSundae();
it.next('hot fudge');
it.next('sprinkles');
it.next('whipped cream');
it.next();
----

* Option 1:  The *toppings* array will have undefined as its last item. 
* An error will occur 
* The generator will be paused, waiting for it's last call to *.next()*

Answer 
====
The toppings array will have *undefined* as its last item.

image:img/gen5.png[]

Because the first call to .next() passes in some data, but that data doesn't get stored anywhere. 
The last call to .next() should have some data since it's being yielded into the last call to *toppings.push()*
====

generators are a powerful new kind of function that is able to pause its execution while also 
maintaining its own state. 
Generators are great for iterating over a list of items one at a time so you can handle each item on its own before moving on to 
the next one. 

Generators will also be used heavily in upcoming additions to the JavaScript language. One upcoming feature that will make sure to use them is link:https://github.com/tc39/ecmascript-asyncawait[async functions].

== 8.27 : Lesson 3 Summary

As great as ES6 is, some browsers can't read it. 
The next chapter there's a way to write ES6 code for the browsers that work with it, and will also work with browsers that are behind.