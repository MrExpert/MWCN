:library: Asciidoctor
:toc:
:toc-placement!:
include::style.adoc[]

= Grow with Google Challenge Notes: Chapter 7

Function notes +
To go back to the README where all the chapters are: click link:README.asciidoc[here].


toc::[]

== 7.1 Updates to Functions 

Here is a little introduction to what the lesson will be about. 

The checklist on the previous chapter was this. Now we can check off Syntax since we completed chapter 6.

* [x] Lesson 1 - *Syntax* - changes and addition to the Javascript Syntax.
* [ ] Lesson 2 - *Functions* - We will investigate updates to JavaScript Functions. 
* [ ] Lesson 3 - *Built-Ins* - We will cover new ES6 built ins. 
* [ ] Lesson 4 - *Developer-Fu* - We will wrap things up by showing you how you can incorporate these latest updates into your next JavaScript project.

<<< 
The two instructors covers what we will be trying to learn in this lesson.

* We will learn the new way to write functions called *arrow functions*. 
* We will also be learning about the new *class* keyword that lets you create functions as classes. 
* With the new ES6 we can now set the default function parameters.
* We can connect different classes together using the new *super* and *extends* keywords.


== 7.2 Arrow Functions 

We're introduced to a new and easier way to write functions. 
This uses the fat arrow in place of function. 

Here is the old way to write a function....
In this example we use the link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map[.map()] method that functions on every element of an array and then gathers the returned values from each function call and makes a new array with the results.
----
const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(function(name) { 
  return name.toUpperCase();
});
----

and then here's the new way using the *=>* 
----
const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(
  name => name.toUpperCase()
);
----

This new method of creating functions makes it a whole lot more easier to understand. +
No more need for _function(x) {code}_ now it's just *x => code*.

== 7.3 Using Arrow Functions 

Functions can either be link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function[function declarations] or link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function[function expressions].

Before I move on with this subject, I need to understand what those two mean. 

* Function declaration is a function that doesn't require variable assignment. They are standalone and cannot be nested within non-function blocks. They also must start with *function* and then name just like how variables must start with var/let/const and then name. 
----
function nameOF(a, b) {
    return a + b;
}

nameOf(3, 2) // 5
nameOf // function 
----


* Function expression can be named or it can be anonymous. Function expressions cannot start with *function*. Typically function expressions are part of a larger expression syntax.

example of a function expression:
----
var a = function() { //anonymous }
var a = function b() { // named }
----

okay, I think I can move on now... 

''''

Arrow functions can only be *expressions*.  The full name of function expression is *arrow function expressions*. So that mean they have to follow the same rules as a function expression.

* stored in a variable
* passed as an argument to a function 
* and stored in an object's property.

=== Writing the arrow function 

Now writing it can get a bit confusing.

old way for *greet('Asser')*
----
const greet = (function(name)) {
    return 'Hello' + name;
}
----

now it's a whole lot more simpler with the arrow function

Here's one with only one parameter
----
const greet = name => `Hello ${name}`;

or

const greet = (name) => `Hello ${name}`;
----

both will print: Hello Asser. In these cases they only have one parameter to worry about. Now what if there are *two or more* items in the parameter list? And what if there are none?

* Here's how it would look like if it was an empty parameter. Seems to require the paranthesis or you can use an underscore in place of the empty paranthesis.
----
const greet = () => code 

or 

const greet = _ => code
----

* multiple parameters also requires the paranthesis. 
----
const greet = (name, age) => code
----

''''
[NOTE]
====

The underscore was entirely new to me so I had to go look it up. 

Another user mentions that () gives the impression that there will not be any arguments so it never bothered to declare any parameter.

Though if you use the underscore, you're telling the function that there will be arguments, but maybe not so just leave the space open.

I'm not entirely sure about all of this though, so I may have to do more research. For right now the underscore just replaces the empty paranthesis.

====
''''
=== concise and block body syntax 

They gave the quiz before talking about this which I thought was unfair. So what does concise and block body syntax mean when it comes to writing functions?

* concise body function +
Up until now, we've been using a concise body syntax which means 
** has no curly braces surrounding the function body 
** and automatically returns the expression. +

example: 
----
const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(
  name => name.toUpperCase()
);
----

* block body function + 
This is needed for when you have more than a single line of code in the arrow function. Though, you can still use this method for a single line if you want to.
** it uses curly braces to wrap the function body 
** A *return* statement needs to be used to actually return something from the function.

example: 
----
const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map( name => {
  name = name.toUpperCase();
  return `${name} has ${name.length} characters in their name`;
});
----

=== arrow function quiz 1

The question is "Which of the following choices have correctly formatted arrow functions?"

NOTE: You can use an underscore to replace the empty paranthesis. They will both result in undefined and maybe an underscore would be better in a sea of paranthesis. I can't seem to find anymore information on this so maybe I'll update this post once I do.

The way it was written confused me so I'm just going to lay it out here. Also, quiz 1 was introduced before talking about concise and block body, so ignore the "must have a return with block" rule for this one.

----
1   setTimeout( () => { console.log('starting the test');
    test.start();}, 2000);
----
++++
    <p class="spoiler">empty parameter and uses block body > yes </p>
++++
----

2   setTimeout( _ => { console.log('starting the test');
    test.start();}, 2000);
----
++++
    <p class="spoiler">empty parameter and uses block body > yes</p>
++++
----

3   const vowels = 'aeiou'.split('');
    const bigVowels = vowels.map((letter) => letter.toUpperCase());
----
++++
    <p class="spoiler">single parameter and uses concise body > yes </p>
++++
----
4   const vowels = 'aeiou'.split('');
    const bigVowels = vowels.map(letter => letter.toUpperCase());
----
++++

    <p class="spoiler">single parameter and uses concise body > yes </p>
++++


=== arrow function quiz 2

Question: Which of these used the correctly formatted arrow functions?

----
1   const color = ['red', 'blue', 'green', 'yellow', 'orange, 'black'];

   const crazyColors = colors.map( color => { 
        const jumble = color.split('').reverse();
        return jumble.join('') + '!';

    });
----

++++
<p class="spoiler">block body needs a return which it does > yes </p>
++++

----

2   const color = ['red', 'blue', 'green', 'yellow', 'orange, 'black'];

    const crazyColors = colors.map( color => {
        colors.split('').reverse().join('') + '!';

    });
----
++++
    <p class="spoiler">block body does not have a return > no </p>
++++
----

3   const color = ['red', 'blue', 'green', 'yellow', 'orange, 'black'];

    const crazyColors = colors.map( color => return color.split('').reverse().join('') + '!');

----
++++
    <p class="spoiler">concise body automatically returns the expression so it doesn't need the return keyword. > no </p>
++++
----

4   const color = ['red', 'blue', 'green', 'yellow', 'orange, 'black'];

    const crazyColors = colors.map( color => color.split('').reverse().join('') + '!');
----
++++
    <p class="spoiler">concise body with no return > yes </p>
++++


== 7.4 Quiz: Convert Function into an Arrow Functions 

Quiz time! 

This one was a breeze considering we spent so much time on the previous!

All we had to do was change the old function to the arrow function 
----
const squares = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(function(square) {
	return square * square;
});
----

is now:
++++
<div class="spoiler">

const squares = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(square => square * square); <p>
<p>
or <p>

const squares = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(square => { return square * square};

</div>
++++

== 7.5 Arrow Functions Recap 

So far I am really enjoying the new arrow functions. Especially the fact we don't need to type in the function keyword anymore. And if we're using the concise version, we don't need {} and return anymore. 
Unfortunately, it doesn't replace all functions. The arrow functions are only for for *function expressions*. 

Now they're telling us that there's another drawback to arrow functions. The *this* keyword is different from the regular functions.

More on that coming right up.

== 7.6 Arrow Functions and the "this" Keyword 

The instructors mention that *this* works differently in arrow functions. 

* The +++<u>Regular Functions</u>+++ way of *this* is *how the function is called*. 
* The +++<u>Arrow Functions</u>+++ way of *this* is *where it's located in the code*.

== 7.7 "this" and Regular Functions 

In this section I'm going to try and relearn *this* by using this link:https://www.youtube.com/watch?v=zE9iro4r918[video] rather than the lesson. I just thought the short chapter on *this* was a bit confusing.

=== Implicit Binding

image:img/this1.png[] +
This would print out his name *Tyler*.

Implicit binding says when the function is being called, look to the left and that is where *this* keyword is going to reference.

''''
Here's a more complicated scenario: +
image:img/this2.png[] +
This would print out only his name: *Jim*.

* *var Person* has the parameters: name and age. Inside were the objects: name, age, and sayName. sayName uses *this.name* which refers to *Person.name*.
* *var jim* puts in the arguments: 'Jim', 42 for *Person*'s name and age parameter. *this* was stored with jim.
* *jim.sayName();* will call sayName using jim's arguments.

=== Explicit Binding with .call, .apply, .bind

==== call()

Now what if the function is separated from the object?
We need to use .call for it to communicate with each other.

image:img/this3.png[] +
This would print: *My name is Stacey*. +
In this example we want to use the function with the stacey object.

SayName is the function. *this* needs to be connected or else it would be confused where to refer to.

''''
==== apply()

Now what if there's an array? This is how .call() may not be the best. +
image:img/this4.png[]

This will print: *My name is Stacey and I know JavaScript, Ruby, and Python*.

This will work, but there's an easier way to pass in what's in the array of languages and parse it for us into the parameters. That's where *.apply()* comes in.

image:img/this5.png[] +
So instead of *.call()* which we will have to manually call one by one, *.apply()* will pass an array of arguments and match it for us.

==== bind()

*.bind()* is a lot like .call as in they work one-by-one, but they're best for creating an entirely new function that can be called later. 

So this is how .call() would have worked: 

----
 var sayName = function(lang1, lang2, lang3) {
    console.log(`My name is ${this.name} and I know ${lang1}, ${lang2}, and ${lang3}`);
};

var stacey = {
    name: 'Stacey',
    age: 34
};

var languages = ['JavaScript', 'Ruby', 'Python']

sayName.call(stacey, languages[0], languages[1], languages[2]);
----

With .bind we're binding it into a new function.

----
var newFn = sayName.bind(stacey, languages[0], languages[1], languages[2]);
----

so now we can just call the newF to get the same result.

----
newFn()
----

==== summary of call, apply, bind

In short, *call()* and *apply()* behave the same way by instantly invoking the function. *.call()* will pass in arguments one by one, while *.apply()* will pass the arrays. +
*.bind()* will behave the same way as .call() but instead of instantly invoking the function, it will instead give us a brand new function that we can call later.

== window Binding 

if we ran this:
----
var sayAge = function() {
  console.log(this.age);
}

var me = {
  age: 25
}

sayAge()
----
We would get *undefined* because there's nothing to the left of the *sayAge()*, not using the *new* Binding, and not using *call/apply/bind*, it will then default to the global *window binding*. 

If we still wanted to call using *sayAge()* we would have to create *window.age = 25;* to give us the result we want.
+
image:img/this6.png[]



=== new Binding

The new Binding is with the constructor function. Using the *new Binding* keyword with the variable *myFather* will create a new object and bound *this* with the new object.

----

function Person(first, last, age, eye) {

    this.firstName = first;
    this.lastName = last;
    this.age = age;
    this.eyeColor = eye
}

var myFather = new Person("John", "Doe", 50, "blue");

console.log(`My father is  ${myFather.age}.`)

----

Okay that was long, but I think I understand how *this* works now.

== 7.8 "this" and Arrow Functions 

The convenience with the arrow function is that *this* inherits the value from the surrounding context.


This is how the regular function would have worked with the constructor function.

image:img/this8.png[]

++++
<p style="background:#ff0582; padding: 4px;">pink would print out: I currently have 3 scoops</p>
<p style="background:#ff0000; padding: 5px;">"But now I have NaN scoops!"</p>
++++

Now here's the new arrow function.

image:img/this7.png[] +
++++
<p style="background:#ff0582; padding: 4px;">pink would print out: I currently have 3 scoops</p>
<p style="background:#ff0000; padding: 5px;">red would print out: But now I have 6 scoops</p>
++++

''''
NOTE: if addScoop() used an arrow function along with setTimeOut(), *this* would refer to global instead.



== 7.9 Default Function Parameters




== 7.10 Defaults and Destructuring 

== 7.11 Quiz: Using Default Function Paramters (2 - 2)

== 7.12 Class Preview

== 7.13 Javascript's Illusion of Classes 

== 7.14 Javascript Classes 

== 7.15 Convert a Function to a Class 

== 7.16 Working with JavaScript Class

== 7.17 Super and Extends 

== 7.18 Extending Classes from ES5 to ES6 

== 7.19 Working with JavaScript Subclasses

== 7.20 Quiz: Building Classes and Subclasses (2 - 3)

== 7.21 Lesson 2 Summary