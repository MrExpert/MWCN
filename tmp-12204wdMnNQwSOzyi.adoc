:library: Asciidoctor
:toc:
:toc-placement!:

= Grow with Google Challenge Notes: Chapter 6

Syntax notes +
To go back to the README where all the chapters are: click link:README.asciidoc[here].


toc::[]

== 6.1: Harmony, ES6, ES2015

We meet our two new instructors for this lesson. Name Richard Kalehoff and James Parkes.

Harmony, ES6, ES2015 means the same thing. They're the biggest update to the JavaScript programming language. Some of the things that has changed with ES6 is: 

* New keywords 
* Different ways of writing functions 
* asynchronous goodies
* and more

In this course, we will explore the additions to the javascript program so we can write faster, cleaner, and more efficient code. +

The lesson will be broken down to four parts. 

* Lesson 1 - *Syntax* - changes and addition to the Javascript Syntax.
* Lesson 2 - *Functions* - We will investigate updates to JavaScript Functions. 
* Lesson 3 - *Built-Ins* - We will cover new ES6 built ins. 
* Lesson 4 - *Developer-Fu* - We will wrap things up by showing you how you can incorporate these latest updates into your next JavaScript project.


== 6.2: Let and Const

Let and Const is one of the keywords that has been added to ES6. 




=== Hoisting

They explain how var isn't perfect how the code below is one example var can get into trouble.

----
function getClothing(isCold) {
    if (isCold) {
        var freezing = 'Grab a Jacket!';
    } else {
        var hot = 'It's a shorts kind of day.';
        console.log(freezing);
    }
}
----

What do you expect to be the output from running *getClothing(false)*? 
It would result as *undefined*

''''

Hoisting is a result of how JavaScript is interpreted by the browser. 
Essentially, before any JavaScript code is executed, all variables are "hoisted", which means they're raised to the top of the function scope. So at run-time, the getClothing() function actually looks more like this..
----
function getClothing(isCold) {
    var freezing, hot;
    if (isCold) {
        freezing = 'Grab a Jacket!';
    } else {
        hot = 'It's a shorts kind of day.';
        console.log(freezing);
    }
}
----

=== Introducing let and const

Now that we understand the problem with variable and hoisting, we can use *let* and *const* to declare a variable because they're scoped *to the block*, not to the function. With var, variables were either scoped globally or locally to an entire function scope.

If a variable is declared using let or const inside of a block of code which is anything within a *{   }* , then the variable is stuck in what is known as the *temporal dead zone* until the variable's declaration is processed. This behavior prevents variables from being accessed only until after they've been declared.

Here's another mini quiz to understand let/const. 

----
function getClothing(isCold) {
    if (isCold) {
        let freezing = 'Grab a Jacket!';
    
    } else {

        let hot = 'It's a shorts kind of day.';
        console.log(freezing);
    
    }

}
----
if we called *getClothing(false*), what would we get?

In this case, there would be a *ReferenceError: freezing is not defined*. 
console.log is calling *freezing*, but freezing is not defined in that block.

Here they just want to remind you that let and const are only available within the block they're declared in.

=== let and const rules


Variables declared with let can be reassigned, but cannot be redeclared in the same scope.

for example:
----
let instructor = 'James';
instructor = 'Richard';
console.log(instructor);
----

let can be reassigned in the same block so the output of this would be *Richard*.

''''
Const however is slightly different.
Variables declared with const must be assigned an initial value, but can't be redeclared in the same scope, and can't be reassigned.

So if we were to use the same example as above but with const, the output would be *James*.

=== var, let, const. Which one should we use?

* var - The instructors recommend ditching var since it is bad practice to use a variable globally. +
* const - It's best to use const because of how strict it is. You would know the identifiers won't change throughout the lifetime of the program.
* let - though if you need something that has to be changed later, then use let.


== 6.3: Quiz: Using Let and Const(1-1)

This section just wants you to edit the following code to use const and let rather than var. 

NOTE: Don't change the order. just replace var.

----
const CHARACTER_LIMIT = 255;
const posts = [
	"#DeepLearning transforms everything from self-driving cars to language translations. AND it's our new Nanodegree!",
	"Within your first week of the VR Developer Nanodegree Program, you'll make your own virtual reality app",
	"I just finished @udacity's Front-End Web Developer Nanodegree. Check it out!"
];

// prints posts to the console
function displayPosts() {
	for (let i = 0; i < posts.length; i++) {
		console.log(posts[i].slice(0, CHARACTER_LIMIT));
	}
}

displayPosts();
----
Since let can be changed, it would be perfect for a for loop.

== 6.4: Template Literals

Definition: link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals[MDN web doc] +
____
Template literals are string literals allowing embedded expressions. You can use multi-line strings and string interpolation features with them. They were called "template strings" in prior editions of the ES2015 specification.
____


=== The obsolete concatenation operator

Along with var being obsolete, now it's the string concatenation operator  (+) . 
The old way was: 

----
const student = {
  name: 'Richard Kalehoff',
  guardian: 'Mr. Kalehoff'
};

const teacher = {
  name: 'Mrs. Wilson',
  room: 'N231'
}

let note = teacher.name + ',\n\n' +
  'Please excuse ' + student.name + '.\n' +
  'He is recovering from the flu.\n\n' +
  'Thank you,\n' +
  student.guardian;
----

Which would read: +
____
Mrs. Wilson,

Please excuse Richard Kalehoff.
He is recovering from the flu.

Thank you,
Mr. Kalehoff
____

''''
The problem was that it gets a bit messy and confusing.
So here they want to introduce *template literals* (previously referred to as _template strings_).

=== Introducing Template Literals 

The new way doesn't use single or double quotes for strings. Instead the whole thing is wrapped in the backticks and the placeholders would be wrapped in *${placeholders}*.

example: 
----
let message = `${student.name} please see ${teacher.name} in ${teacher.room} to pick up your report card.`;
----
Which would read: 
____
Richard Kalehoff please see Mrs. Wilson in N231 to pick up your report card.
____

The new way shines when it comes to multi-line. 

For example: 

----
let note = `${teacher.name},

Please excuse ${student.name},
He is recovering from the flu.

Thank you,
${student.guardian}`;
----

The template literals preserve newlines as part of the string. 

NOTE: Embedded expressions inside template literals can do more than just reference variables. You can perform operations, call functions and use loops inside embedded expressions.


== 6.5: Quiz: Build an HTML Fragment(1-2)

Using what we learned about *Template Literals*, we edit the old way to the new way. This lesson did really prove that the new way is definitely better. Don't forget the back ticks.

Here's the finished: 

----

    const cardHTML = `<div class="card"> <h3 class="name"> ${animal.name} </h3> 
    <img src="${animal.name}.jpg" alt="${animal.name}" class="picture">
    <div class="description">
    <p class="fact">${animal.fact} </p>
        <ul class="details">
            <li><span class="bold">Scientific Name</span>: ${animal.scientificName} </li>
            <li><span class="bold">Average Lifespan</span>: ${animal.lifespan} </li>
            <li><span class="bold">Average Speed</span>: ${animal.speed} </li>
            <li><span class="bold">Diet</span>: ${animal.diet} </li>
        </ul>
            <p class="brief">${animal.summary}</p>
        </div>
    </div>;`
----

== 6.6: Destructuring

Definition: link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment[Destructuring Assignment]
____
The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.

____

The new way is a lot more simpler and goes by positions. The value of the array is now on the left side but it shares the same position as the original. If you need to leave something out, it can just have an empty #, ,# for each position you want to leave out. +

''''

=== Destructuring from an array

Here's the old way of destructuring an array: 
----
const point = [10, 25, -34];

const x = point[0];
const y = point[1];
const z = point[2];

console.log(x, y, z);
----

''''

And here's the new way to destrucure an array:

----
let positions = ['Gabrielle', 'Jarrod', 'Kate', 'Fernando', 'Mike', 'Walter'];
let [first, second, third] = positions;
----

position second is shared with Jarrod. 

=== Destructuring from an object
The old way for destructuring an object was like this: 

----
const gemstone = {
type: 'quartz', 
color: 'rose',
karat: 21.29
};

const type = gemstone.type;
const color = gemstone.color;
const karat = gemstone.karat;

console.log(type, color, karat);
----


''''
The new way for dstructuring an object should be written like this: 

----
const gemstone = {
    type: 'quartz',
    color: 'rose',
    karat: 21.29
};

const {type, color, karat} = gemstone;

console.log(type, color, karat);
----

NOTE: When you destructure an object and store a function into a variable, it no longer has access to *this*.


== 6.7: Quiz: Destructuring Arrays(1-3)

In here is a little quiz to see if we understand destructuring arrays. 

Here are the changes when we only want the colors from the original array as a variable.
----
const things = ['red', 'basketball', 'paperclip', 'green', 'computer', 'earth', 'udacity', 'blue', 'dogs'];

const [one, , ,two, , , ,three] = things;
----

== 6.8: Object Literal Shorthand

When it comes to objects, sometimes it can be repetitive. 
The old way with objects initialization we used to do it this way: 

----
let type = 'quartz';
let color = 'rose';
let carat = 21.29;

const gemstone = {
  type: type,
  color: color,
  carat: carat
};

console.log(gemstone);
----
The unecessary part is having to put *type: type*, *color: color*, and *carat: carat*. It's redundant and unecessary now that 
ES6 figured out a way to simplify this. 
Now we can remove duplicate variables names from object properties if the properties hve the same name as the variable being assigned to them. 

new way: 
----
let type = 'quartz';
let color = 'rose';
let carat = 21.29;

let gemstone = { type, color, carat };

----

''''

There is also a shorthand way to add methods to objects.

The old way of adding a method in an object was:

----
const gemstone = {
type,
color,
carat,
calculateWorth: function() {

}
}
----

The ES6 way is: 
----

let gemstone = {
type,
color,
carat,
calculateWorth() { 

}
}

----

Basically *function* keyword was unecessary and was removed.


== 6.9: Lesson 1 Checkup

First half summary:

* *let* and *const* are the new ways of declaring variables. *let* can be reassigned, but cannot be redeclared. *const* cannot be reassigned nor redeclared. 
* *template literals* replaces the concatenation operator. instead of _'string' + PH + 'string' + '\n' + PH + 'string'_ , you can now envelope everything with a back tick, placeholders are just encased in ${placeholder}, and strings are just left alone. Also, any new line is preserved as part of the string. example: 
----
let message = 
`
${placeholder} string string 
string string 
`
----


== 6.10: Iteration
== 6.11: Family of For Loops
== 6.12: For...of Loop
== 6.13: Quiz: Writing a For...of Loop(1-4)
== 6.14: Spread... Operator
== 6.15: ...Rest Parameter
== 6.16: Quiz: Using the Rest Parameter(1-5)
== 6.17: Lesson Summary