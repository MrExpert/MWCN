:library: Asciidoctor
:toc:
:toc-placement!:

= Grow with Google Challenge Notes: Chapter 3

Introducing the Service Worker Notes +
To go back to the README where all the chapters are: click link:README.asciidoc[here].



toc::[]

== 3.1: An Overview of Service Worker
All service worker really is is a single javascript file that sits between the website and the network.
SW is a web worker which means it runs separately from the website. The user cannot see it. The SW cannot access the DOM. +
It does control web pages and by control, it intercepts requests and sends it to wherever you tell it to.

=== Registering the SW

The first step you need to do is register the service worker by giving the location of the service worker.
Inside the () is the location of the service worker.

----
navigator.serviceWorker.register('/sw.js')
----

After registering it, it will then return a promise so you can get call backs for success or failure.

NOTE: But wait, what does a promise really mean. I had to go look it up link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises[here]. +
_"Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function."_

----
    navigator.serviceWorker.register('/sw.js').then(function(reg) {
    console.log('yay');
    }).catch(function(err) {
    console.log('Boo!');
    });
----

NOTE: If by any chance you accidentally registerred it when there's already a SW running,
it will just return a promise from the existing registration. Not a big deal.

''''

You can also provide a scope for the SW during registration.
A scope are the directory/files that SW can control. It will ignore anything else.

----
navigator.serviceWorker.register('/sw.js', {
    scope: '/my-app/'
})
----

If given a scope /my-app/, scope will only go to these: +
/my-app/ +
/my-app/hello/world/ +

It cannot go to these: +
/ +
/another-app/ +
/my-app (same as '/' because it doesn't have the trailing slash)

NOTE: You do not need scope. The default scope is where the path sits in. So be sure to put it in the correct place +
example: */foo/sw.js* will affect */foo/* +
example 2:  */foo/bar/sw.js* will affect */foo/bar/*

=== What goes on in the SW?

SW listens for events. Just like regular Javascript, you can react to them or even prevent the default and do your own thing.
Here's a sample code he featured for listening events that he will elaborate later.

----
self.addEventListener('install', function(event) {});
self.addEventListener('activate', function(event) {});
self.addEventListener('fetch', function(event) {});
----

=== What browsers support service worker?
Here's the link:https://jakearchibald.github.io/isserviceworkerready/[link] to see which browsers support Service Worker.
By the looks of it, all of the major ones do, but only chrome supports Background sync.

Jake mentions that SW is progressive enhancement ready. Which means it won't hurt those browsers that doesn't support it. They just won't get the benefits. 
To do so, wrap your registration in an if feature detect.

----
if (navigator.serviceWorker) {
    navigator.serviceWorker.register('/sw.js');
}
----

== 3.2: Quiz: Scoping Quiz

Mike wants to remind us the importance of where the scope affects.
So if the scope is /foo/, which of these would it affect? 

*a*: / +
*b*: /sw.js +
*c*: /foo +
*d*: /foo.html +
*e*: /foo/ +
*f*: /foo/bar/index.html +
*g*: /foo/bar +

The answer is /foo/ or anything after /foo/ which would be E, F, and G.

== 3.3: Adding a Service Worker to the Project

We are finally diving into the code. 

=== Testing

*Step 1*: The first thing we need to do is head over to our index.js file. +
public> js > sw > index.js +
*Step 2*: Currently, the file is empty. Jake wants us to add a simple console.log("hello") 
so the build system picks it up and shoots it to the root of the server in sw.js which is located in +
build>public> sw.js +
*Step 3*: After adding the console.log() into the index, you will see that it was also inserted into sw.js. 
The extra code in sw.js is from the output of Babel which the script runs through.

=== addEventListener fetch

We are going to work on fetch.

*Step 1*: Head back over to *index.js* in *public>js>sw>* +
*Step 2*: delete the previous test console.log and add in a listener.

----
self.addEventListener('fetch', function() {
}
----

''''

Once you have a service worker, and a user navigates to the page within the SW's scope, it controls the web page.
The website goes to the SW and triggers a fetch event. It will also retrieve every request event triggered by that page such as css, js, images. You get a fetch event for each, even if the requests were to another origin.
We can inspect the requests with Javascript and give it a fetch like so...

----
self.addEventListener('fetch', function(event) {
    console.log(event.request);
});
----


== 3.4: Quiz: Registering a Service Worker

This quiz session wants you to register the service worker so it can run as soon as we start our app. We reviewed it in the previous
lesson and now we just have to put it in practice. First we have to set up the template by getting Jake's git branch for this lesson.

*Step 1*: If you already have the server running, open up another console and navigate to the wittr folder.
Type in: +
----
git reset --hard
git checkout task-register-sw
----
*Step 2*: Open public> js> main> IndexController.js and find:
----
IndexController.prototype._registerServiceWorker = function() {
// Todo: register service worker
};
----

NOTE: The IndexController.js file takes care of the setup of the app. That's where we can setup a web socket for live updates.
Javascript does not have private methods. It's good to start methods with an underscore if they will only ever be called by other methods of this object.

*Step 3*: 
Mike wants you to register the SW where he says to "register service worker" inside the code. +
He also wants the scope to be the whole origin, so you can leave scope out and it will default. 

Fortunately, Jake had already given us the necessary code to register SW. All we have to do is combine them into line 15: +
Here's a refresher of the code:

Here's the if statement to check if the browser supports service worker. If it doesn't, it outputs nothing.
----
  if (navigator.serviceWorker) {
    navigator.serviceWorker.register('/sw.js');
----

A normal registration returns a promise so you can use it to get call backs if it was a success or failure:
----
    navigator.serviceWorker.register('/sw.js').then(function(reg) {
    console.log('yay');
    }).catch(function(err) {
    console.log('Boo!');
    });
----

*Step 4*: To see if there are any errors, it's best to get used to pulling out the devtools in chrome. +
To find dev tools, go to the 3 dots on the far right side next to all the extensions > more tools > Developer Tools. +
There, you can find your hotkey to open up dev tools. Mine is *Ctrl + Shift + I* +
image:img/devtools.png[] +
*Step 5*:
Once registered, test to see if it was successful by going over to localhost:8889 and enter *registered* in the test ID. +
*Step 6*:
You should see *"Service worker successfully registered"*

=== The way Jake registers SW

Jake decided not to wrap the code in a browser support check and just put the check in a single line. +
With the registration returning a promise, he wants it to spit out a message to see if it failed or succeeded.
----
if (!navigator.serviceWorker) return;

navigator.serviceWorker.register('/sw.js').then(function(reg) {
    console.log('Registration worked!');
}).catch(function() {
    console.log('Registration failed');
});
----

If it succeeded, refresh again and in the console in the devtools should spit out: *"Registration worked!"* +
Over at Test ID in localhost:8889, you should get the message: *"Service worker successfully registered!"* when you type in: *registered*.

WARNING: I've noticed on the forums there were some issues getting this to be registered even when the code was entered correctly. Try the following: +
*1st*: Check your bash. Restart if you see this error: +
image:img/consoleERR1.png[] +
*Ctrl C* and then turn it back on with *npm run serve*. +
*2nd*: If your bash isn't spitting errors, try to do a hard refresh of chrome. +  
*Shift + refresh.* +
*3rd*: Try clearing the cache if the other two doesn't work.

=== Dev tools Console Requests logs 

After the success of Jake's code, you will notice in the devtools console after a refresh it shows all the requests logs. +
image:img/webconsole1.png[] +

The scope restricts the pages it controls, but it will intercept any request made by these controlled pages regardless of the URL.
You can change these requests and respond to it with something entirely different. +
Service Worker is limited to HTTPS, because if it wasn't encrypted, any user could intercept it and add/remove/modify the content.

== 3.5: The Service Worker Lifecycle

Jake let's us know that we have to do 2 refreshes to see the results. When we made changes to the service worker, SW didn't pick up that change.
The steps that SW took when we registered it and why it took 2 refreshes. 

=== Why it takes 2 refreshes to see Service Worker after registration.

- website is open. We'll call it Website_1 
- We register SW. 
- We hit refresh on the website_1 to send out requests and get a response.
- new window client gets made. We'll call it Website_2
- Website_2 made a request off to the network and back.
- Website_1 went away and Website_2.0 stays. + 
Though if the response came back that the browser should save the resource to disk via download dialog, website_1 would have stayed. Since the response we got was just a page, the website_1 is gone.
- The response was a page and website_1 is gone. The request went out for css, images, and also the new javascript. The registered Service Worker. +

IMPORTANT: *Q*: How come we didn't see the request log after one refresh? +
*A*: Because Service Worker only control pages when they're completely loaded, and the page was loaded
before the service worker existed.

- any request by website_2 will bypass the service worker script.
- When we refresh again, a new website client was made. We call it website_3 and website_2 is now gone.
- Since Service Worker was up with website_2 (but not running), it is now running with website_3.
- Any new requests will go through Service Worker.

=== Why changes to Service Worker doesn't change until after you reopen the page.
Making changes to the service worker script is different. Jake shows us that when you 
made changes to the script, nothing happened after a refresh.
The new version of the service worker won't make any changes until all pages using
 the current version are gone. because it only wants one version of the website running
  at a given time. Such as native apps.  

*Q* What does Native App mean? +
*A*: 
____
According to: link:http://searchsoftwarequality.techtarget.com/definition/native-application-native-app[] +
A native application (native app) is an application program that has been developed for use on a particular platform or device.

Because native apps are written for a specific platform, they can interact with and take advantage of operating system features and other software that is typically installed on that platform. Because a native app is built for a particular device and its operating system, it has the ability to use device-specific hardware and software, meaning that native apps can take advantage of the latest technology available on mobile devices such as a global positioning system (GPS) and camera. This can be construed as an advantage for native apps over Web apps or mobile cloud apps.
The term "native app" is often mentioned in the context of mobile computing because mobile applications have traditionally been written to work on a specific device platform. A native app is installed directly on a mobile device and developers create a separate app version for each mobile device. The native app may be stored on the mobile device out of the box, or it can be downloaded from a public or private app store and installed on the mobile device. Data associated with the native app is also stored on the device, although data can be stored remotely and accessed by the native app. Depending on the nature of the native app, Internet connectivity may not be required. 
____

Here is what's going on with Service Worker. 

- Service_Worker 1 looks for changes in resources and byte identical.
- If yes, it becomes the new version. Service_Worker 2. 
- Service_Worker 2 doesn't take control yet because Service_Worker 1 is still running with the website.
- Service_Worker 2 is waiting for all pages using Service Worker 1 to close to ensure only one version of the website is running.
- Once you close that page, the new website 3 will use Service Worker 2.

=== Testing changes to Service Worker
- Head over to *public>js>sw>Index.js*
- Modify the code to *console.log("Hello World");*.
- Go over to the wittr app *localhost:8888*
- One refresh you shouldn't see any changes and only see the normal requests.
- Close the page and pull up console. You will see *"hello world"* instead of the normal requests.

NOTE: SW uses the same update process as browsers such as chrome. Chrome downloads updates in the background but won't take over until the browser closes and reopens again.
chrome will let us know there's an update ready when the icon on the top right changes color.

=== Intro to an upcoming lesson with cache.
Jake lets us know that in an upcoming lesson we will learn how to use the service worker to look for updates and then notify the user that there is an update available.
The Service Worker will go through the browser's cache just like all requests do. Jake recommends keeping the cache time on the service worker short. Jake recommends keeping the cache time zero on all service worker projects.

CAUTION: Jake lets us know that if you set the service Worker script to cache for more than a day, the browser will ignore it and set the cache to 24 hours.
Does that mean the service worker not work after 24 hours? No, the update checks will bypass the browser cache if the service worker it has is over a day old.

== 3.6: Quiz: Enabling Service Worker Dev Tools

This lesson Jake wants us to install Chrome Canary. This course was taped in 2015 so most of the features are actually in the normal chrome. I'm going to skip this install.

== 3.7: Quiz: Service Worker Dev Tools

Here, Jake is giving us an overview of the Dev tools.

=== Dev Tools Console

- First is the console. Any code that is run here will be run against the documents. Though, the Service Worker lives outside the documents.
To get to the Service Worker script in console, there is a drop down menu, you can select service worker and type anything in console for that script. +
image:img/webconsole2.png[] 

=== Dev Tools Sources

- To find the debugging menu that Jake was playing around with go to sources tab. The UI is actually the same, but the navigator is hidden by default. Just press the arrow and the navigator will pop up. +
 Navigate to sw.js>localhost:8888>public/js/sw>index.js
- While in index.js, Jake put in a breakpoint in our fetch event by pressing 2 on the side.
- Refresh the page and notice that the script gets paused. 
- To unpause, just unclick the number and press the play button.

=== Dev Tools Service Worker

Service Worker has its very own panel. It's not in the Resources like Jake has it, but it's actually in the *Application* panel. +
image:img/SW1.png[] +

- There you will see the link *Unregister* that will refetch the Service Worker from scratch.
- Instead of tabs, we just get a status information. Right now the status should be green. It should have the message *"activated and is running"* If you have a service worker waiting underneath it, it probably just means you made some changes. More on that on the quiz. 

=== The Quiz to give you the waiting status 

*Step 1*: Mike wants you to get the waiting status. First you need to ready the template if you want to.
----
git reset --hard
git checkout log-requests
----
*Step 2*: Make any changes to the sw.js file. A different console log. anything. +
*Step 3*: Go over to the dev tools> application> service workers +
*Step 4*: You should now see your green status for an active one and an orange status that says it's waiting. +
image:img/SW2.png[] +
*Step 5*: After that, head over to the settings page: *localhost:8889* and type in the Test-ID: *sw-waiting* +
*Step 6*: You should see the message *"Yey! There's a service worker waiting!"*.

== 3.8: Quiz: Service Worker Dev Tools 2

This lesson, Mike wants us to get that new service worker active. 

- Mike reminds us that what we need to do is close the current pages that are using the old Service Worker. +
- When you reopen wittr, and reopen the Dev Tools>Application>Service Workers you will now notice that there is no more service worker waiting and there's only an active one.
- To confirm, go to settings page (localhost:8889) and type into the Test ID: *sw-active*
- You should see the message *"No service worker waiting! Yay!"*.

== 3.9: Service Worker Dev Tools Continued

Jake explains that having to reopen the page during development can be annoying. +

NOTE: You can do a hard refresh by *Shift + refresh*. It will reload the page but bypasses the Service Worker. It will set the waiting as the active.

TIP: Instead of doing *Shift + refresh*, you can just check the *update on reload* option. +
image:img/SW3.png[] +
The option will change the Service Worker life cycle to be developer friendly. Now that when you hit refresh, rather than just refreshing the page, it fetches a service worker and treats it as a new version whether it was changed or not and it will become active straight away. After that, the page refreshes. +

WARNING: This is only for developers. The user will be stuck with the old way of having to close the page and reopening it to get the new service worker.


== 3.10: Hijacking Requests

So far we've only seen requests go from page to SW, and then from SW's fetch event to the internet through the HTTP cache. +
Here, we're going to catch the request when it accesses the Service Worker and respond ourselves without it going to the internet.
This is actually an important step to going offline first. 

=== Introducing hijacking with event.respondWith()

- To get started, Jake wants you to go to the service worker script at *public>js>sw>index.js*.
- in the fetch script, replace what's inside with *event.respondWith()* 

NOTE: event.respondWith tells the browser that we're going to handle this request ourselves. Here's more information on it link:https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith[here].

- event.respondWith() takes in a response object or a promise that resolves with a response.
- To create a response you just type in *new response()*.  +
        * The first parameter is the body of the response. which can be a blob, a buffer, a string, or some other thing. Here's a documentation of how we can use link:https://developer.mozilla.org/en-US/docs/Web/API/Response/Response[new Response()]
- In Jake's example, he's going to play with a string.
----
event.respondWith(
    new Response("Hello World")
    );
----

- Once the hello world is entered, go over to the wittr page and refresh it. You will notice that it has been completely hijacked with the simple message: "Hello World".

=== Adding html to the hijacker

Jake edited the new Response string to have HTML, but it passed as plain text instead. +
image:img/webconsole3.png[] +

You can easily change it to HTML by setting the header as part of the new Response. 

- The second parameter of new Response is an object.
- the header's property takes an object of headers and values.
- set the foo header to be bar like this: 'foo': 'bar'

----
new Response('Hello <b>World</b>', {
    headers: {'foo': 'bar'}
}
);
----

== 3.11: Quiz: Hijacking Requests 1 Quiz

Here we will be hijacking the requests the way Mike wants us to. 

=== Hijack the website with a string and changing it to read in HTML.

*Step 1*: Mike wants us to prepare our template.
----
git reset --hard
git checkout task-custom-response
----
*Step 2*: Over at public>js>sw>Index.js Mike will have a todo in the fetch event. +
*Step 3*: Mike wants us to make the event listener be able to read HTML. The HTML element can be anything as long as the class name is *"a-winner-is-me"*. +

''''
code refresher: +
the new Response
----
event.respondWith(
    new Response(
    // The new Response takes in two parameters.
    // The first parameter is the body so it can be a string
    // The second parameter can be an object)
    )
----
''''
code refresher: +
The basic bold html element string with a fubar class. This will be put into parameter # 1. 
Mike says it can be any HTML element as long as it has the class *"a-winner-is-me"*. +
----
<b class="fubar"> Hello World </b>

----
''''
code refresher: +

adding a new header object. This would go into parameter # 2
----
{ headers: {'foo': 'bar'} }
----
''''

NOTE: We need to overwrite the old header name: *Content-Type* to read HTML. +
The default is text/plain. We need to change it to *text/HTML*. 


*Step 4*: Once you're done with the code, Mike wants you to go to the webpage and refresh. +
*Step 5*: The HTML of that page should be applied and see if the header changed to read HTML by going to devtools>network>response headers. +
*Step 6*: Once you see the result, confirm it by going to the settings page (localhost:8889) and put in the test ID: *html-response* +
*Step 7*: You should see the result: *"Custom HTML response found! Yay!"*

=== How Jake hijacked the request to read html

----
event.respondWith(
    new Response('Hello <b class="a-winner-is-me">world</b>', {
        headers: {'Content-Type': 'text/html'}}
    ))
----

With the new hijacking, you can still see hello world offline and every other network condition. 

== 3.12: Hijacking Requests 2

=== Introducing fetch
Here we will go to the network for the response, but give something else that was requested using +
*fetch(url)* +
fetch let's you make network requests and let's you read the response. Here is how you write a fetch request: +

----
fetch('/foo').then(function(response) {
    return response.json();
}).then(function(data) {
    console.log(data);
}).catch(function() {
    console.log('It failed');
})
----

=== Describing what's going on with the fetch code: 

*fetch('foo')* - it will return a promise +
*.then(function(response)* - which will resolve to a response. +
*return response.json();* - then we will read the response's JSON. +
*.then(function(data) { console.log(data)* - Here is the results. +
*.catch(function() { console.log("It failed")* - You can catch errors from either the request or reading the response. 

=== back to our code event.respondWith()
Jake reminds us that event.respondWith takes either a response or a promise that resolves to a response. +
Fetch returns a promise that resolves to a response. So fetch and event.respondWith() work together very well. +
Here, we're going to respond with a fetch for a gif image. 
----
event.respondWith(
    fetch('/imgs/dr-evil.gif)
----

The fetch API performs a normal browser fetch. When this is inserted to our current SW script, it gave the gif response to everything.


== 3.13: Quiz: Hijacking Requests 2 Quiz

Mike wants us to give this gif response to only a particular request. +

*Step 1*: To ready the template: +
----
git reset --hard
git checkout gif-response
----
*Step 2*: Head over to public>js>sw>index.js and read the TODO: +
*Step 3*: The task s to respond with a gif if the request URL ends with .jpg. +

We will definitely need a fetch method to take a full request object as well as a URL
----
event.respondWith(
    fetch(event.request).then(function(response) {
    if () {
    return;
    }
    else {
    return; 
    }
}).catch(function() {
    return;
    })
);

----

NOTE: The main thing we had to modify is the if statement and what it returns. +
 *.then* is for success and *.catch* is for failure

'''' 

code refresher: +
We will have to check for an url that ends with .jpg.
----
if (event.request.url.endsWith('.jpg'))
or
if (/.jpg$/.test(event.request.url))

----
NOTE: To learn more about RegExr, here's a great link:https://regexr.com/[link].

''''
code refresher: +
Here's how to fetch the image to replace with:
----
fetch('url')
----

*Step 4*: Once you have it working, go over to the settings page (localhost:8889) and type in the test ID: *gif-response* +
*Step 5*: You should see the message *"Images are being intercepted!"*

=== Here's how it worked
Well unfortunately Jake didn't give us the answer of how he did this, but the forums and slack helped me get it working.

----
  event.respondWith(
    fetch(event.request).then(function(response) {
      if (event.request.url.endsWith('.jpg')) {
        return fetch('/imgs/dr-evil.gif');
      }
    return response;
    }).catch(function() {
      return new Response("Nope! You broke something, idiot!");
    })
  );
----

=== My struggle on this

I struggled with this for a few hours trying to get it to work. My main issue was what to return. +
* turns out _return response fetch(url)_ didn't work. +
*  _return new Response(fetch(url))_ didn't work. +
* and _new Response 'url'_ didn't work. +

Boy did it get very frustrating. Turns out I didn't really understand *fetch()*. I can't find any good documentations about new Response() and fetch(), but to quote someone who understands it better: +
____
Mario Ruiz on Slack: +
this line *return new Response(fetch('/imgs/dr-evil.gif'));* should be something like

----
return fetch('/imgs/dr-evil.gif');
----

fetch already returning a response promise, is not necesarry to wrap it again into a Response object.
____

Then I remembered on my notes when I wrote: +
____
event.respondWith takes either a response or a promise that resolves to a response.
Fetch returns a promise that resolves to a response. So fetch and event.respondWith() work together very well.

----
event.respondWith(
    fetch('/imgs/dr-evil.gif)
----
____

So if I understand this correctly: + 
 *.fetch()* _is_ a response. And having them together in _return response fetch()_ is repetitive. Okay, I think I can finally move on now..

== 3.14: Hijacking Requests 3

Instead of th image gif hijacking any jpg url like the previous lesson, Jake wants to give us a 404 page response. Also, we can give a message if the fetch fails or our network is offline. 
A bit of a refresher: The page can send a request then we can intercept and send to the network. Instead of sending the response back, we can look at it and send back something else. +
=== The network fetch() for a 404 page.

----
self.addEventListener('fetch, function(event) {
    event.respondWith(
        fetch(event.request).then(function(response) {
            if (response.status === 404) {
                return new Response("Whoops, not found!");
            }
                return response;
        }).catch(function() {
                return new Response("Something went wrong");
    })
    );
});
----

=== What the code in the 404 page means

*Step 1*: +
*event.respondWith()* We will respond with a network fetch for the request. This is what the browser would do anyway. +
*Step 2*: +
*fetch(event.request)* the fetch method will take a full request object as well as a URL. The fetch will return a promise. +
*Step 3*: + 
*.then(function(response) {} )* Since fetch returns a promise, we can attach a .then to get the result if it was successful. +
*Step 4*: + 
Whatever we put inside .then(function(response) {*here*} is the callback. It will become the value for the promise. +
*Step 5*: +
*if (response.status === 404)*  Here we can look at the response ourselves, and if the response is a 404 Not Found... +
*Step 6*: +
*return new Response* We can respond with our own message. +
*Step 7*: +
*return response* Otherwise we can just return the response that was received. + 
*Step 8*: +
*.catch(function(response) {} )* .catch will be the fallback if there was a failure in the fetch or if the network is offline +
*Step 9*: +
Again with the .then, you can give it a *return new Response("message");*

== 3.15: Quiz: Hijacking Requests 3 Quiz

In this lesson, they us to chain two fetch requests together. 

*Step 1*: First we have to ready our template. +

----
git reset --hard
git checkout error-handling
----

*Step 2*: Instead of the new response being a custom text, Mike wants us to respond with the dr-evil.gif. +
*Step 3*: We have to fetch from the network. +

code refresher:
----
fetch("url")
----


*Step 4*: Then we have to navigate to a page that doesn't exist within wittr and see if the image shows. +
*Step 5*: Once you see it working, confirm at the settings page (localhost:8889) and enter the Test ID: *gif-404* +
*Step 6*: You should see the message *"Yay! 404 pages get gifs!"*

=== The answer to giving the gif image to the 404 request 

This one was easy if we reflect back to my revelation and rant in lesson link:ch3.asciidoc#my-struggle-on-this[3.13] +
All we needed to do was add the fetch inside the if response. +

----
return fetch('/imgs/dr-evil.gif');
----

== 3.16: Caching and Serving Assets

We have been doing simple texts and images, but it's about time to actually respond with something useful. To do this we need to store the HTML, CSS, etc.
There's a special API for this called the *cache API*.

=== Special cache API 

* to *Open* a cache, type the following with the name of the cache. If we've never opened that cache name before, it will create one and return it.  
----
caches.open('my-stuff').then(function(cache) { // } )
----

NOTE: A cache box contains requests and response pairs from any secure origin. We can use it to store fonts, scripts, images, etc from our own origin as well as elsewhere on the web.

* to *add* cache items, type the following and pass in a request/URL and a response.

----
cache.put(request, response);

or

cache.addAll ([
'/foo',
'/bar'
])
----

WARNING: the addAll with the arrays way is atomic. Which means if any of those in the arrays fail to cache, none of them will be added.

NOTE: addAll uses fetch under the hood, so requests will go via the browser cache.

* to *retrieve* something out of the cache, we type in the following. It will only pass a request/URL. It will then return a promise for a matching response if one is found or null.

----
cache.match(request);

or

caches.match(request);
//will search in any cache starting with the oldest.
----

=== The install event

Now that we have somewhere to store our stuff, but now when do we store it?
Jake shows that there's another service worker event that will install the cache.

There are steps that the service worker install has to do 

*Step 1*: We run the service worker the first time. +
*Step 2*: The browser won't let the new service worker take control pages until it's install phase has been completed. We are in control of what that involves. +
*Step 3*: We use the opportunity to get everything we need from the network and create a cache for the content.

*Step 4*: To create an install event, we make a new self.addEventListener. +
*Step 4*: inside the install eventListener, we added in an *event.waitUntil()*. It let's us signal the progress of the install. +
*Step 5*: We then pass it a promise. If and when the promise resolves, the browser knows the install is complete. If the promise rejects, it knows the install failed, and should be discarded.

----
self.addEventListener('install', function(event) {
    event.waitUntil()

})
----

== 3.17: Quiz: Install and Cache Quiz

Here we are going to try and install and cache.

*Step 1*: We have to ready the template.

----
git reset --hard
git checkout task-install
----

*Step 2*: What Mike wants us to do is open a cache name 'wittr-static-v1' and add cache the urls from urlsToCache.

code refresher: 

----
#open a cache
caches.open('my-stuff').then(function(cache) { // } 

#to add cache
cache.put(request, response); 
or
cache.addALL (['x', 'y', 'z'])

----
*Step 3*: To verify if we've made the cache, head over to Dev Tools > application> Cache Storage> 'wittr-static-v1' +
image:img/devtools2.png[] +
*Step 4*: To confirm that it was a success, head over to the settings page (localhost:8889) and enter in the Test ID: *install-cached* +
*Step 5*: You should see the message: *"Yay! The cache is ready to go!"*

=== How Jake installed the cache 

This is how Jake created the caches.

----
 event.waitUntil(
    caches.open('wittr-static-v1').then(function(cache) {
    return cache.addAll([
    '/',
    'js/main.js',
    'css/main.css',
    'imgs/icon.png',
    'https://fonts.gstatic.com/s/roboto/v15/2UX7WLTfW3W8TclTUvlFyQ.woff',
    'https://fonts.gstatic.com/s/roboto/v15/d-6IYplOFocCacKzxwXSOD8E0i7KZn-EPnyo3HZu7kw.woff'
  ]);
    })

 )

an alternative way to use the array is just to call the variable *urlsToCache* like this:

return cache.allAll(urlsToCache)
----


== 3.18: Quiz: Cache Response Quiz

Now that we have created the caches, we should be able to use it now. 

== 3.19: Updating the Static Cache
== 3.20: Quiz: Update Your CSS Quiz
== 3.21: Quiz: Update Your CSS 2
== 3.22: Adding UX to the Update Process
== 3.23: Quiz: Adding UX Quiz
== 3.24: Trigger an Update
== 3.25: Quiz: Triggering an Update Quiz
== 3.26: Quiz: Caching the Page Skeleton